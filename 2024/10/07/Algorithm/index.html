<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Algorithm | Mark Goyens的闻雅轩</title><meta name="author" content="Mark Goyens"><meta name="copyright" content="Mark Goyens"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] 图论算法1. 最短路径A. Dijkstra(单源问题) 细节   每次贪心地将最短的、可以拓展点的边并入集合，最终获得最短的路径。   每次加入点之后更新最小距离，寻找到下一个最短路径的点加入集合。（不保证得到的是一颗树，但保证点到点最小）   代码实现   1234567891011121314151617181920212223vector&lt;int&gt; Dijkstra">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm">
<meta property="og:url" content="http://example.com/2024/10/07/Algorithm/index.html">
<meta property="og:site_name" content="Mark Goyens的闻雅轩">
<meta property="og:description" content="[TOC] 图论算法1. 最短路径A. Dijkstra(单源问题) 细节   每次贪心地将最短的、可以拓展点的边并入集合，最终获得最短的路径。   每次加入点之后更新最小距离，寻找到下一个最短路径的点加入集合。（不保证得到的是一颗树，但保证点到点最小）   代码实现   1234567891011121314151617181920212223vector&lt;int&gt; Dijkstra">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/head.jpg">
<meta property="article:published_time" content="2024-10-07T08:19:22.529Z">
<meta property="article:modified_time" content="2024-10-07T08:25:18.288Z">
<meta property="article:author" content="Mark Goyens">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/head.jpg"><link rel="shortcut icon" href="/image/logo.png"><link rel="canonical" href="http://example.com/2024/10/07/Algorithm/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Algorithm',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-10-07 16:25:18'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/image/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/image/backview.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Mark Goyens的闻雅轩"><span class="site-name">Mark Goyens的闻雅轩</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Algorithm</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-07T08:19:22.529Z" title="发表于 2024-10-07 16:19:22">2024-10-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-07T08:25:18.288Z" title="更新于 2024-10-07 16:25:18">2024-10-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Algorithm"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<h1 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a><strong>图论算法</strong></h1><h2 id="1-最短路径"><a href="#1-最短路径" class="headerlink" title="1. 最短路径"></a>1. 最短路径</h2><h3 id="A-Dijkstra-单源问题"><a href="#A-Dijkstra-单源问题" class="headerlink" title="A. Dijkstra(单源问题)"></a>A. Dijkstra(单源问题)</h3><ul>
<li><p>细节</p>
<pre><code>  每次贪心地将最短的、可以拓展点的边并入集合，最终获得最短的路径。
  每次加入点之后更新最小距离，寻找到下一个最短路径的点加入集合。（不保证得到的是一颗树，但保证点到点最小）
</code></pre>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Dijkstra</span><span class="params">(vector&lt;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;&amp;edges,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//传入k是起始点</span></span><br><span class="line">    <span class="comment">//初始化为不可达</span></span><br><span class="line">    <span class="type">int</span> n=edges.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dicts</span>(n,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;qu;</span><br><span class="line">    <span class="comment">//存储当前距离，当前节点</span></span><br><span class="line">    qu.<span class="built_in">push</span>(&#123;<span class="number">0</span>,k&#125;);</span><br><span class="line">    dicts[k]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [d,u]=qu.<span class="built_in">top</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(dicts[u]&lt;d)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[v,w]:edges[u])&#123;</span><br><span class="line">            <span class="type">int</span> d1=d+w;</span><br><span class="line">            <span class="keyword">if</span>(dicts[v]&gt;d1)&#123;</span><br><span class="line">                qu.<span class="built_in">push</span>(&#123;d1,v&#125;);</span><br><span class="line">                dicts[v]=d1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dicts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>封装</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> Dijkstra=[&amp;](vector&lt;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;&amp;edges,<span class="type">int</span> k) -&gt; vector&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="type">int</span> n=edges.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dicts</span>(n,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(&#123;<span class="number">0</span>,k&#125;);</span><br><span class="line">    dicts[k]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [d,u]=qu.<span class="built_in">top</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(dicts[u]&lt;d)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[v,w]:edges[u])&#123;</span><br><span class="line">            <span class="type">int</span> d1=d+w;</span><br><span class="line">            <span class="keyword">if</span>(dicts[v]&gt;d1)&#123;</span><br><span class="line">                qu.<span class="built_in">push</span>(&#123;d1,v&#125;);</span><br><span class="line">                dicts[v]=d1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dicts;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li>时间复杂度： O(eloge)</li>
<li>空间复杂度： O(e)</li>
</ul>
</li>
</ul>
<h3 id="B-BellmanFord-单源问题"><a href="#B-BellmanFord-单源问题" class="headerlink" title="B. BellmanFord(单源问题)"></a>B. BellmanFord(单源问题)</h3><p>适用于负边</p>
<ul>
<li><p>分析</p>
<pre><code>  要路径最小，一条路径长度最多为n-1，否则形成环不可能最短，而对于每一条边都遍历n-1次，看在什么时候加入最优，以达成找到最短路径的目的。
</code></pre>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">BellmanFord</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;edges,<span class="type">int</span> n,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//边信息edges:edges[i]=&#123;u,v,w&#125; 顶点数n 出发节点k</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dist</span>(n,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    dist[k]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//最多经过n-1次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;edge:edges)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[edge[<span class="number">0</span>]]+edge[<span class="number">2</span>]&lt;dist[edge[<span class="number">1</span>]])&#123;</span><br><span class="line">                dist[edge[<span class="number">1</span>]] = dist[edge[<span class="number">0</span>]] + edge[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>封装</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> BellmanFord=[&amp;](vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;edges,<span class="type">int</span> n,<span class="type">int</span> k) -&gt; vector&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dist</span>(n,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    dist[k]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;edge:edges)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[edge[<span class="number">0</span>]]+edge[<span class="number">2</span>]&lt;dist[edge[<span class="number">1</span>]])&#123;</span><br><span class="line">                dist[edge[<span class="number">1</span>]] = dist[edge[<span class="number">0</span>]] + edge[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度： O(ne)</p>
</li>
<li><p>空间复杂度： O(n)</p>
</li>
</ul>
</li>
</ul>
<h3 id="C-Floyd-多源问题"><a href="#C-Floyd-多源问题" class="headerlink" title="C. Floyd(多源问题)"></a>C. Floyd(多源问题)</h3><ul>
<li><p>细节</p>
<pre><code>  利用动态规划的思想，将各点之间的距离求出。转移方程为dp[i][j]=min(dp[i][k]+dp[k][j],dp[i][j])，其中k∈集合内的点，每次先确定当前的中间点k，将中间点一个一个加进去选取最优，而不是先枚举ij后选择k，这样会导致在某些时候距离不正确。
</code></pre>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">Floyd</span>(vector&lt;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;&amp;edges)&#123;</span><br><span class="line">    <span class="type">int</span> n=edges.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0x3f3f3f3f</span>));</span><br><span class="line">    <span class="comment">//这一步可有可无，dp[i][i]的状态不会影响到最后其余点，但不初始化不要使用dp[i][i]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[i][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[u,w]:edges[i])&#123;</span><br><span class="line">            dp[i][u]=w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意是先枚举k，再枚举ij</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i][k]+dp[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>封装</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> Floyd=[&amp;](vector&lt;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;&amp;edges) -&gt; vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="type">int</span> n=edges.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0x3f3f3f3f</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[i][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[u,w]:edges[i])&#123;</span><br><span class="line">            dp[i][u]=w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i][k]+dp[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度： O($n^3$)</p>
</li>
<li><p>空间复杂度： O($n^2$)</p>
</li>
</ul>
</li>
</ul>
<h3 id="D-BFS-DFS解决固定边权问题"><a href="#D-BFS-DFS解决固定边权问题" class="headerlink" title="D. BFS&#x2F;DFS解决固定边权问题"></a>D. BFS&#x2F;DFS解决固定边权问题</h3><p>用于边权固定的图。</p>
<ul>
<li><p>BFS</p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以k节点开始，以及预处理好邻接表edges，顶点数n</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">dicts</span>(n);</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt;<span class="built_in">visited</span>(n);</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;qu;</span><br><span class="line">qu.<span class="built_in">push</span>(k);</span><br><span class="line">visited[k]=<span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> depth=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="type">int</span> nq=qu.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(nq--)&#123;</span><br><span class="line">        <span class="type">int</span> u=qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:edges[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">                dicts[v]=depth;</span><br><span class="line">                qu.<span class="built_in">push</span>(v);</span><br><span class="line">                visited[v]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    depth++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>BFS维护最短路径</p>
<p>  维护一个pre数组，存储当前节点的上一个节点。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以k节点开始，以及预处理好邻接表edges，顶点数n</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">dicts</span>(n);</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt;<span class="built_in">visited</span>(n);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">pre</span>(n);</span><br><span class="line"><span class="built_in">iota</span>(pre.<span class="built_in">begin</span>(),pre.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;qu;</span><br><span class="line">qu.<span class="built_in">push</span>(k);</span><br><span class="line">visited[k]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="type">int</span> nq=qu.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(nq--)&#123;</span><br><span class="line">        <span class="type">int</span> u=qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:edges[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">                pre[v]=u;</span><br><span class="line">                qu.<span class="built_in">push</span>(v);</span><br><span class="line">                visited[v]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 起点k到任一点e的路径可以通过以下方法求得，保证k、e互达。</span></span><br><span class="line">ptr=e;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;round;</span><br><span class="line"><span class="keyword">while</span>(pre[ptr]!=ptr)&#123;</span><br><span class="line">    round.<span class="built_in">push_back</span>(ptr);</span><br><span class="line">    ptr=pre[ptr];</span><br><span class="line">&#125;</span><br><span class="line">round.<span class="built_in">push_back</span>(ptr);</span><br><span class="line"><span class="built_in">reverse</span>(round.<span class="built_in">begin</span>(),round.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
</li>
<li><p>01-BFS最短路</p>
<p>  相对于DJ更小的常数。</p>
<ul>
<li><p>细节</p>
<p>  解决只存在边权为0&#x2F;x的图的最短路。最优的就是先使用0边权的边，其次再使用x边权的边。对应到实现上就是将0边权的放在队列前，将x边权的放在队列后。</p>
</li>
<li><p>代码示例</p>
<p>  空网格（$grid[r][c]&#x3D;&#x3D;0$）前往无代价，有障碍网格（$grid[r][c]&#x3D;&#x3D;1$）代价为1。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=grid.<span class="built_in">size</span>(),m=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">d</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,INT_MAX));</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    deque&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;q;</span><br><span class="line">    <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    q.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [r,c]=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[dr,dc]:dirs)&#123;</span><br><span class="line">            <span class="type">int</span> r0=r+dr,c0=c+dc;</span><br><span class="line">            <span class="keyword">if</span>(r0&gt;=<span class="number">0</span>&amp;&amp;c0&gt;=<span class="number">0</span>&amp;&amp;r0&lt;n&amp;&amp;c0&lt;m&amp;&amp;d[r0][c0]&gt;d[r][c]+grid[r0][c0])&#123;</span><br><span class="line">                d[r0][c0]=d[r][c]+grid[r0][c0];</span><br><span class="line">                grid[r0][c0]?q.<span class="built_in">push_back</span>(&#123;r0,c0&#125;):q.<span class="built_in">push_front</span>(&#123;r0,c0&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="2-拓扑排序"><a href="#2-拓扑排序" class="headerlink" title="2. 拓扑排序"></a>2. 拓扑排序</h2><p>找到环、非环元素。</p>
<ul>
<li><p>细节</p>
<pre><code>  不断将入度为0的节点去除，并减少其指向的节点的度，再次检查是否有入度为0的节点。最终获得的就是图中的环。
</code></pre>
</li>
<li><p>代码实现</p>
<ul>
<li><p>BFS</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">Topologic</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;edges,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//p::edges[i]:&#123;ui,vi&#125;  n:节点数</span></span><br><span class="line">    <span class="comment">//r::true-&gt;非环元素 false-&gt;环元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">indeg</span>(n);</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt;<span class="built_in">visited</span>(n);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">next</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;edge:edges)&#123;</span><br><span class="line">        next[edge[<span class="number">0</span>]].<span class="built_in">push_back</span>(edge[<span class="number">1</span>]);</span><br><span class="line">        indeg[edge[<span class="number">1</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;qu;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(indeg[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            qu.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> cur=qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        visited[cur]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:next[cur])&#123;</span><br><span class="line">            indeg[v]--;</span><br><span class="line">            <span class="keyword">if</span>(indeg[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                qu.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>DFS</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">Topologic</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;edges,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//edges[i]:&#123;ui,vi&#125;  n:节点数</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">indeg</span>(n);</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt;<span class="built_in">visited</span>(n);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">next</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;edge:edges)&#123;</span><br><span class="line">        next[edge[<span class="number">0</span>]].<span class="built_in">push_back</span>(edge[<span class="number">1</span>]);</span><br><span class="line">        indeg[edge[<span class="number">1</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> cur)&#123;</span><br><span class="line">        visited[cur]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:next[cur])&#123;</span><br><span class="line">            indeg[v]--;</span><br><span class="line">            <span class="keyword">if</span>(!indeg[v])&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!indeg[i]&amp;&amp;!visited[i])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> visited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度： O(n+e)</p>
</li>
<li><p>空间复杂度： O(n+e)</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-二部图"><a href="#3-二部图" class="headerlink" title="3. 二部图"></a>3. 二部图</h2><h3 id="A-最大匹配问题"><a href="#A-最大匹配问题" class="headerlink" title="A. 最大匹配问题"></a>A. 最大匹配问题</h3><ul>
<li><p>细节</p>
<pre><code>  匈牙利算法。
  在匹配不上的时候尝试改变配对，直到无法改变。
  最大匹配数等于最小点覆盖数（去掉最少的点清除所有的边）。
</code></pre>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> getMaxMatch=[&amp;](vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;next)&#123;</span><br><span class="line">    <span class="type">int</span> _n=next.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;left;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;qu;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt;<span class="built_in">visited</span>(_n);</span><br><span class="line">    <span class="comment">/* 获取左端点 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;_n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            <span class="type">bool</span> isleft=<span class="number">1</span>;</span><br><span class="line">            qu.<span class="built_in">push</span>(i);</span><br><span class="line">            visited[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> qn=qu.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">while</span>(qn--)&#123;</span><br><span class="line">                    <span class="type">int</span> cur=qu.<span class="built_in">front</span>();</span><br><span class="line">                    qu.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(isleft)left.<span class="built_in">push</span>(cur);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:next[cur])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">                            visited[v]=<span class="literal">true</span>;</span><br><span class="line">                            qu.<span class="built_in">push</span>(v);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                isleft=!isleft;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 尝试推测 */</span></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt;<span class="built_in">used</span>(_n);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">partner</span>(_n,<span class="number">-1</span>);</span><br><span class="line">    function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; match=[&amp;](<span class="type">int</span> cur)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:next[cur])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[v])&#123;</span><br><span class="line">                used[v]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(partner[v]==<span class="number">-1</span>||<span class="built_in">match</span>(partner[v]))&#123;</span><br><span class="line">                    partner[v]=cur;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!left.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> cur=left.<span class="built_in">front</span>();</span><br><span class="line">        left.<span class="built_in">pop</span>();</span><br><span class="line">        used.<span class="built_in">assign</span>(_n,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">match</span>(cur))&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O($n^2m^2$)</p>
</li>
<li><p>空间复杂度：O(nm)</p>
</li>
</ul>
</li>
</ul>
<h2 id="4-欧拉图"><a href="#4-欧拉图" class="headerlink" title="4. 欧拉图"></a>4. 欧拉图</h2><h3 id="A-寻找欧拉通路-欧拉回路"><a href="#A-寻找欧拉通路-欧拉回路" class="headerlink" title="A. 寻找欧拉通路&#x2F;欧拉回路"></a>A. 寻找欧拉通路&#x2F;欧拉回路</h3><ul>
<li><p>Hierholzer算法</p>
<ul>
<li><p>细节</p>
<pre><code>  流程如下：
  1. 从起点出发，进行深度优先搜索。起点为任意（欧拉图）/为出度比入度大1的点。
  2. 每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。
  3. 如果没有可移动的路径，则将所在节点加入到栈中，并返回。
  4. 依次取出栈元素，就是一条欧拉路径。
  先遍历再放入是本算法的关键，能走通的节点总比不难走通的节点后入栈（反转后先经过）。
</code></pre>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findItinerary</span><span class="params">(<span class="type">int</span> n,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">next</span>(n);</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;<span class="built_in">degree</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;edge:edges)&#123;</span><br><span class="line">        next[edge[<span class="number">0</span>]].<span class="built_in">push_back</span>(edge[<span class="number">1</span>]);</span><br><span class="line">        degree[edge[<span class="number">0</span>]].first++;</span><br><span class="line">        degree[edge[<span class="number">1</span>]].second++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> start_place=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[place,d]:degree)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d.first&gt;d.second)&#123;</span><br><span class="line">            start_place=place;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;ret;</span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;dfs=[&amp;](<span class="type">int</span> u)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!next[u].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> v=next[u].<span class="built_in">back</span>();</span><br><span class="line">            next[u].<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(start_place);</span><br><span class="line">    <span class="built_in">reverse</span>(ret.<span class="built_in">begin</span>(),ret.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O(n)</p>
</li>
<li><p>空间复杂度：O(n)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-树"><a href="#5-树" class="headerlink" title="5. 树"></a>5. 树</h2><ul>
<li><p>二叉树</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>N叉树</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definition for a Node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="A-树的遍历"><a href="#A-树的遍历" class="headerlink" title="A. 树的遍历"></a>A. 树的遍历</h3><h4 id="i-先序遍历"><a href="#i-先序遍历" class="headerlink" title="i. 先序遍历"></a>i. 先序遍历</h4><ul>
<li><p>细节</p>
<pre><code>  二叉树：根-&gt;左子树-&gt;右子树
  N叉树：根-&gt;子树1-&gt;...-&gt;子树n
</code></pre>
</li>
<li><p>代码实现</p>
<ul>
<li><p>DFS</p>
<ul>
<li><p>二叉树</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Preorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)<span class="built_in">Preorder</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)<span class="built_in">Preorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>N叉树</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Preorder</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;child:root-&gt;children)&#123;</span><br><span class="line">        <span class="built_in">Preorder</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>BFS</p>
<ul>
<li><p>二叉树</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Preorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt;stk;</span><br><span class="line">    TreeNode* ptr=root;</span><br><span class="line">    <span class="keyword">while</span>(ptr||!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(ptr)&#123;</span><br><span class="line">            <span class="comment">/* do something */</span></span><br><span class="line">            stk.<span class="built_in">push</span>(ptr);</span><br><span class="line">            ptr=ptr-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ptr=stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            ptr=ptr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>N叉树</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    stack&lt;Node *&gt; stk;</span><br><span class="line">    <span class="keyword">if</span>(root)st.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node * node = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">/* do something */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = node-&gt;children.<span class="built_in">rbegin</span>(); it != node-&gt;children.<span class="built_in">rend</span>(); it++) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="ii-中序遍历"><a href="#ii-中序遍历" class="headerlink" title="ii. 中序遍历"></a>ii. 中序遍历</h4><ul>
<li><p>细节</p>
<pre><code>  二叉树：左子树-&gt;根-&gt;右子树
  N叉树：没意义，无法确定“中”
</code></pre>
</li>
<li><p>代码实现</p>
<ul>
<li><p>DFS</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)<span class="built_in">Inorder</span>(root-&gt;left);</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)<span class="built_in">Inorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BFS</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt;stk;</span><br><span class="line">    TreeNode* ptr=root;</span><br><span class="line">    <span class="keyword">while</span>(ptr||!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(ptr)&#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(ptr);</span><br><span class="line">            ptr=ptr-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ptr=stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">/* do something */</span></span><br><span class="line">            ptr=ptr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="iii-后序遍历"><a href="#iii-后序遍历" class="headerlink" title="iii. 后序遍历"></a>iii. 后序遍历</h4><ul>
<li><p>细节</p>
<pre><code>  二叉树：左子树-&gt;右子树-&gt;根
  N叉树：子树1-&gt;...-&gt;子树n-&gt;根
</code></pre>
</li>
<li><p>代码实现</p>
<ul>
<li><p>DFS</p>
<ul>
<li><p>二叉树</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Postorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)<span class="built_in">Inorder</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)<span class="built_in">Inorder</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>N叉树</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Preorder</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;child:root-&gt;children)&#123;</span><br><span class="line">        <span class="built_in">Preorder</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>BFS</p>
<ul>
<li><p>二叉树</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Postorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;tag;</span><br><span class="line">    stack&lt;TreeNode*&gt;stk;</span><br><span class="line">    TreeNode* ptr=root;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(ptr)&#123;</span><br><span class="line">            <span class="comment">//不断找左节点 并记录为第一次遇到</span></span><br><span class="line">            stk.<span class="built_in">push</span>(ptr);</span><br><span class="line">            tag.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">            ptr=ptr-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!tag.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(tag.<span class="built_in">top</span>())&#123;</span><br><span class="line">                <span class="comment">//这时候是第三次遇到这个元素</span></span><br><span class="line">                <span class="comment">/* use stk.top() to do something */</span></span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                tag.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ptr=stk.<span class="built_in">top</span>();</span><br><span class="line">                ptr=ptr-&gt;right;</span><br><span class="line">                <span class="comment">//将当前栈顶的元素记录为第二次遇到</span></span><br><span class="line">                tag.<span class="built_in">top</span>()++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(ptr||!tag.<span class="built_in">empty</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>N叉树</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Postorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;Node*,<span class="type">int</span>&gt;cnt;</span><br><span class="line">    stack&lt;Node*&gt;stk;</span><br><span class="line">    Node* ptr=root;</span><br><span class="line">    <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()||ptr!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(ptr!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(ptr);</span><br><span class="line">            <span class="keyword">if</span>(ptr-&gt;children.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="comment">//记录为第一次遇到</span></span><br><span class="line">                cnt[ptr]=<span class="number">0</span>;</span><br><span class="line">                ptr=ptr-&gt;children[<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125;</span><br><span class="line">        ptr=stk.<span class="built_in">top</span>();</span><br><span class="line">        <span class="comment">//更新遇见次数</span></span><br><span class="line">        <span class="type">int</span> index=cnt[ptr]<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;ptr-&gt;children.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            cnt[ptr]=index;</span><br><span class="line">            ptr=ptr-&gt;children[index];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* use ptr do something */</span></span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            cnt.<span class="built_in">erase</span>(ptr);</span><br><span class="line">            ptr=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="iv-邻接表表示的树的遍历"><a href="#iv-邻接表表示的树的遍历" class="headerlink" title="iv. 邻接表表示的树的遍历"></a>iv. 邻接表表示的树的遍历</h4><p>利用树的性质，遍历树的各个节点一次。</p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:next[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v!=pre)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="B-树的重建"><a href="#B-树的重建" class="headerlink" title="B. 树的重建"></a>B. 树的重建</h3><ul>
<li><p>先序+中序</p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=preorder.<span class="built_in">size</span>();</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;idx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        idx[inorder[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    function&lt;TreeNode*(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)&gt;get=[&amp;](<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> il,<span class="type">int</span> ir)-&gt;TreeNode*&#123;</span><br><span class="line">        <span class="keyword">if</span>(il&gt;ir)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> root_val=preorder[pl];</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(root_val);</span><br><span class="line">        <span class="keyword">if</span>(pl==pr)<span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i_root=idx[root_val];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ls=i_root-il,rs=ir-i_root;</span><br><span class="line">        root-&gt;left=<span class="built_in">get</span>(pl<span class="number">+1</span>,pl+ls,il,i_root<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=<span class="built_in">get</span>(pr-rs<span class="number">+1</span>,pr,i_root<span class="number">+1</span>,ir);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>中序+后序</p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;idx;</span><br><span class="line">    <span class="type">int</span> n=inorder.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        idx[inorder[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    function&lt;TreeNode*(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)&gt;getRes=[&amp;](<span class="type">int</span> il,<span class="type">int</span> ir,<span class="type">int</span> pl,<span class="type">int</span> pr)-&gt;TreeNode*&#123;</span><br><span class="line">        <span class="keyword">if</span>(il&gt;ir)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> root_val=postorder[pr];</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(root_val);</span><br><span class="line">        <span class="keyword">if</span>(il==ir)<span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">int</span> pos=idx[root_val],ls=pos-il;</span><br><span class="line">        root-&gt;left=<span class="built_in">getRes</span>(il,pos<span class="number">-1</span>,pl,pl+ls<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=<span class="built_in">getRes</span>(pos<span class="number">+1</span>,ir,pl+ls,pr<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getRes</span>(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>先序+后序</p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">constructFromPrePost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=postorder.<span class="built_in">size</span>();</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;idx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        idx[postorder[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    function&lt;TreeNode*(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)&gt;getRes=[&amp;](<span class="type">int</span> prel,<span class="type">int</span> prer,<span class="type">int</span> pol,<span class="type">int</span> por)-&gt;TreeNode*&#123;</span><br><span class="line">        <span class="keyword">if</span>(prel&gt;prer)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> root_val=preorder[prel];</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(root_val);</span><br><span class="line">        <span class="keyword">if</span>(prel==prer)<span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l_sub_root=preorder[prel<span class="number">+1</span>],lss=idx[l_sub_root]-pol<span class="number">+1</span>;</span><br><span class="line"></span><br><span class="line">        root-&gt;left=<span class="built_in">getRes</span>(prel<span class="number">+1</span>,prel+lss,pol,idx[l_sub_root]);</span><br><span class="line">        root-&gt;right=<span class="built_in">getRes</span>(prel+lss<span class="number">+1</span>,prer,idx[l_sub_root]<span class="number">+1</span>,por<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getRes</span>(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="C-最小（大）生成树"><a href="#C-最小（大）生成树" class="headerlink" title="C. 最小（大）生成树"></a>C. 最小（大）生成树</h3><ul>
<li><p>普里姆算法</p>
<ul>
<li><p>细节</p>
<pre><code>  每次从当前集合的点里找到最短的、可以拓展点集的边将其点与边并入当前集合，不断贪心地进行。
  很像迪杰斯特拉算法的思想，迪杰斯特拉是以到点最小，而普里姆是集合到点最小，后者不能保证点到点最小，但保证了边权和最小。
</code></pre>
</li>
<li><p>代码实现</p>
<p>  默认从0顶点出发，返回生成树的邻接矩阵。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> getMiniSpanTree=[&amp;](vector&lt;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;&amp;edges) -&gt; vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="type">int</span> n=edges.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">retG</span>(n);</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;<span class="built_in">lowest</span>(n,&#123;<span class="number">0x3f3f3f3f</span>,<span class="number">-1</span>&#125;);</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    lowest[<span class="number">0</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [cost,u]=qu.<span class="built_in">top</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(lowest[u].first&lt;cost)<span class="keyword">continue</span>;</span><br><span class="line">        lowest[u].first=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(u!=lowest[u].second)&#123;</span><br><span class="line">            retG[u].<span class="built_in">push_back</span>(lowest[u].second);</span><br><span class="line">            retG[lowest[u].second].<span class="built_in">push_back</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[v,w]:edges[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(lowest[v].first&gt;w)&#123;</span><br><span class="line">                qu.<span class="built_in">push</span>(&#123;w,v&#125;);</span><br><span class="line">                lowest[v]=&#123;w,u&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num==n?retG:vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O(nlogn)</p>
</li>
<li><p>空间复杂度：O(n)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>克鲁斯卡尔算法</p>
<ul>
<li><p>细节</p>
<p>  将边从小到大排序，将可以连接两个不同连通分支的边加入边集。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> getMiniSpanTree=[&amp;](vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;edges,<span class="type">int</span> n) -&gt; vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(),edges.<span class="built_in">end</span>(),[&amp;](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp;e1,<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp;e2)&#123;</span><br><span class="line">        <span class="keyword">return</span> e1[<span class="number">2</span>]&lt;e2[<span class="number">2</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="function">UnionFind <span class="title">uf</span><span class="params">(n)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="type">int</span>&gt;&gt;&gt;<span class="built_in">ret</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:edges)&#123;</span><br><span class="line">        <span class="type">int</span> u=e[<span class="number">0</span>],v=e[<span class="number">1</span>],w=e[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(!uf.<span class="built_in">connected</span>(u,v))&#123;</span><br><span class="line">            uf.<span class="built_in">findAndUnite</span>(u,v);</span><br><span class="line">            ret[u].<span class="built_in">push_back</span>(&#123;v,w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O(eloge)</p>
</li>
<li><p>空间复杂度：O(n)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="D-共同祖先问题"><a href="#D-共同祖先问题" class="headerlink" title="D. 共同祖先问题"></a>D. 共同祖先问题</h3><ul>
<li><p>单次查询</p>
<ul>
<li><p>数组模式</p>
<ul>
<li><p>代码实现</p>
<ul>
<li><p>从序号1开始</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lowestCommonAncestor</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u!=v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;v)swap(u,v);</span><br><span class="line">        v&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从序号0开始</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lowestCommonAncestor</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u!=v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;v)swap(u,v);</span><br><span class="line">        v=(v<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O(logn)</p>
</li>
<li><p>空间复杂度：O(1)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>指针模式</p>
<ul>
<li><p>代码实现</p>
<ul>
<li><p>普适</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root||root==p||root==q)<span class="keyword">return</span> root;</span><br><span class="line">    TreeNode* left=<span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">    TreeNode* right=<span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">    <span class="keyword">if</span>(left&amp;&amp;right)<span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(left)<span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二叉搜索树</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val&lt;root-&gt;val&amp;&amp;q-&gt;val&lt;root-&gt;val)<span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val&gt;root-&gt;val&amp;&amp;q-&gt;val&gt;root-&gt;val)<span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O(n)</p>
</li>
<li><p>空间复杂度：O(n)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>预处理多次查询</p>
<ul>
<li><p>细节</p>
<ul>
<li>倍增DP思想维护<code>parent[i][j]</code>代指第$i$个节点的第$2^j$个祖先</li>
<li>维护<code>d[i]</code>代指节点$i$到根节点的距离</li>
<li>查询节点$u,v$的共同祖先时：<ul>
<li>找到$bigger_{plot}$的第$d[bigger_{plot}]-d[smaller_{plot}]$的节点代替该节点<ul>
<li>若$u!&#x3D;v$，找到$u,v$从第$2^{m-1}$（$m$取决于最大可能的祖先的距离的二进制长度）到$2^0$个的祖先，如果不同就说明该处更靠近共同祖先节点此时更新$u,v$为对应位置的祖先。最终再往前一个节点，就是公共祖先。</li>
<li>若$u&#x3D;&#x3D;v$，则找到对应的公共祖先。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>代码实现</p>
<ul>
<li><p>预处理</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">p</span>(n),<span class="built_in">d</span>(n);</span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)&gt;get=[&amp;](<span class="type">int</span> u,<span class="type">int</span> pre,<span class="type">int</span> f)&#123;</span><br><span class="line">    p[u]=pre;</span><br><span class="line">    d[u]=f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:next[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v!=pre)&#123;</span><br><span class="line">            <span class="built_in">get</span>(v,u,f<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">get</span>(<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">parent</span>(n);</span><br><span class="line"><span class="keyword">auto</span> get_parent=[&amp;](vector&lt;<span class="type">int</span>&gt;&amp;p)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        parent[i].<span class="built_in">push_back</span>(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">bool</span> none=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> next=parent[i][j<span class="number">-1</span>]!=<span class="number">-1</span>?parent[parent[i][j<span class="number">-1</span>]][j<span class="number">-1</span>]:<span class="number">-1</span>;</span><br><span class="line">            parent[i].<span class="built_in">push_back</span>(next);</span><br><span class="line">            <span class="keyword">if</span>(next!=<span class="number">-1</span>)none=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span>(none)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">get_parent</span>(p);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获得最近共同祖先</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> get_kth_node=[&amp;](<span class="type">int</span> u,<span class="type">int</span> k)&#123;</span><br><span class="line">    <span class="type">int</span> ret=u,pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k&amp;&amp;ret!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos&gt;=parent[ret].<span class="built_in">size</span>())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)ret=parent[ret][pos];</span><br><span class="line">        pos++;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> get_lca=[&amp;](<span class="type">int</span> u,<span class="type">int</span> v)&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[u]&gt;d[v])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v=<span class="built_in">get_kth_node</span>(v,d[v]-d[u]);</span><br><span class="line">    <span class="keyword">if</span>(u==v)&#123;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=parent[u].<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> pu=parent[u][i],pv=parent[v][i];</span><br><span class="line">        <span class="keyword">if</span>(pu!=pv)&#123;</span><br><span class="line">            u=pu,v=pv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[u][<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="E-将树分为和相等的子树"><a href="#E-将树分为和相等的子树" class="headerlink" title="E. 将树分为和相等的子树"></a>E. 将树分为和相等的子树</h3><ul>
<li><p>细节</p>
<p>  利用dfs，每次走向一个子节点，计算子节点对此节点的奉献：定义为子节点$sum$不足$target$时奉献就是$sum$，当超过时就是不合法状态返回$-1$，当与$target$相等时自成一组则奉献为0。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> u,<span class="type">int</span> pre,<span class="type">int</span> target)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">    <span class="type">int</span> cur=val[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:next[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v!=pre)&#123;</span><br><span class="line">            <span class="type">int</span> sub=<span class="built_in">dfs</span>(v,u,target);</span><br><span class="line">            <span class="keyword">if</span>(sub&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            cur+=sub;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur&gt;target)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cur&lt;target)&#123;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="F-时间戳判断定义根下的父子关系"><a href="#F-时间戳判断定义根下的父子关系" class="headerlink" title="F. 时间戳判断定义根下的父子关系"></a>F. 时间戳判断定义根下的父子关系</h3><ul>
<li><p>细节</p>
<p>  引入时间戳概念，记录先序、后序的时间序列。</p>
<p>   当两个节点为$u_{t1},u_{t2},v_{t1},v_{t2}$</p>
<ul>
<li>$u_{t1}&lt;v_{t1} &amp;&amp; u_{t2}&lt;v_{t2}$ 各位于root的两颗子树</li>
<li>$u_{t1}&lt;v_{t1} &amp;&amp; u_{t2}&gt;v_{t2}$ 位于root的一颗子树下且$u$是$v$的祖先</li>
<li>$u_{t1}&gt;v_{t1} &amp;&amp; u_{t2}&gt;v_{t2}$ 各位于root的两颗子树</li>
<li>$u_{t1}&gt;v_{t1} &amp;&amp; u_{t2}&lt;v_{t2}$ 位于root的一颗子树下且$v$是$u$的祖先</li>
</ul>
</li>
<li><p>例子</p>
<ul>
<li><p>从树中删除边的最小分数</p>
<p>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/">https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/</a></p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录子树的异或值 -&gt; 无法定位对应区域异或值</span></span><br><span class="line">    <span class="comment">// 引入时间戳记录每个节点遍历的时间（先序、后序）设为t1,t2</span></span><br><span class="line">    <span class="comment">// 当两个节点为u_t1,u_t2,v_t1,v_t2</span></span><br><span class="line">    <span class="comment">//      - u_t1&lt;v_t1&amp;&amp;u_t2&lt;v_t2 各位于root的两颗子树</span></span><br><span class="line">    <span class="comment">//      - u_t1&lt;v_t1&amp;&amp;u_t2&gt;v_t2 位于root的一颗子树下且u是v的祖先</span></span><br><span class="line">    <span class="comment">//      - u_t1&gt;v_t1&amp;&amp;u_t2&gt;v_t2 同1</span></span><br><span class="line">    <span class="comment">//      - u_t1&gt;v_t1&amp;&amp;u_t2&lt;v_t2 位于root的一颗子树下且v是u的祖先</span></span><br><span class="line">    <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">next</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:edges)&#123;</span><br><span class="line">        next[e[<span class="number">0</span>]].<span class="built_in">push_back</span>(e[<span class="number">1</span>]);</span><br><span class="line">        next[e[<span class="number">1</span>]].<span class="built_in">push_back</span>(e[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> time=<span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">t1</span>(n),<span class="built_in">t2</span>(n),<span class="built_in">sum</span>(n);</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;getInfo=[&amp;](<span class="type">int</span> u,<span class="type">int</span> pre)&#123;</span><br><span class="line">        t1[u]=++time;</span><br><span class="line">        sum[u]=nums[u];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:next[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(v!=pre)&#123;</span><br><span class="line">                sum[u]^=<span class="built_in">getInfo</span>(v,u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t2[u]=++time;</span><br><span class="line">        <span class="keyword">return</span> sum[u];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">getInfo</span>(<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> m=n<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> res=INT_MAX;</span><br><span class="line">    <span class="keyword">auto</span> get=[&amp;](<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(a,b),c)-<span class="built_in">min</span>(<span class="built_in">min</span>(a,b),c);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;n;u++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v=u<span class="number">+1</span>;v&lt;n;v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t1[u]&lt;t1[v]&amp;&amp;t2[u]&gt;t2[v])&#123;</span><br><span class="line">                res=<span class="built_in">min</span>(res,<span class="built_in">get</span>(sum[<span class="number">0</span>]^sum[u],sum[u]^sum[v],sum[v]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t1[u]&gt;t1[v]&amp;&amp;t2[u]&lt;t2[v])&#123;</span><br><span class="line">                res=<span class="built_in">min</span>(res,<span class="built_in">get</span>(sum[<span class="number">0</span>]^sum[v],sum[v]^sum[u],sum[u]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res=<span class="built_in">min</span>(res,<span class="built_in">get</span>(sum[<span class="number">0</span>]^sum[v]^sum[u],sum[u],sum[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="G-节点的dfs序"><a href="#G-节点的dfs序" class="headerlink" title="G. 节点的dfs序"></a>G. 节点的dfs序</h3><ul>
<li><p>细节</p>
<p>  引入节点的dfs序可以很方便地表达节点的范围，以将其放入线段树中维护。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> idx=<span class="number">0</span>;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;<span class="built_in">bound</span>(n);</span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;getBound=[&amp;](<span class="type">int</span> u,<span class="type">int</span> pre)&#123;</span><br><span class="line">    bound[u].first=idx++;</span><br><span class="line">    <span class="type">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:next[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v!=pre)&#123;</span><br><span class="line">            size+=<span class="built_in">getBound</span>(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bound[u].second=bound[u].first+size;</span><br><span class="line">    <span class="keyword">return</span> size<span class="number">+1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">getBound</span>(<span class="number">0</span>,<span class="number">-1</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-圈（环）"><a href="#6-圈（环）" class="headerlink" title="6. 圈（环）"></a>6. 圈（环）</h2><h3 id="A-Floyd-判圈算法"><a href="#A-Floyd-判圈算法" class="headerlink" title="A. Floyd 判圈算法"></a>A. Floyd 判圈算法</h3><ul>
<li><p>细节</p>
<p>  对一个存在圈的图，使用慢指针slow每次走一格、快指针fast每次走两格。</p>
<p>  如果存在圈，那他们一定会相遇，此时假设fast走了起点到圈入口的距离a，再绕圈走了n圈，最后走到里圈入口b距离的点与slow相遇，此时此刻slow走了a，再走了b。同时假设还需要走c才能重新回到起点。</p>
<p>  $$<br>  2(a+b)&#x3D;a+b+n(b+c)<br>  $$</p>
<p>  可知：</p>
<p>  $$<br>  a&#x3D;c+(n−1)(b+c)<br>  $$</p>
<p>  故此时将slow放回起点且slow和fast每次走一格，slow和fast正好可以在圈的入口相遇。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *fptr=head,*sptr=head;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fptr==<span class="literal">nullptr</span>||fptr-&gt;next==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        fptr=fptr-&gt;next-&gt;next;</span><br><span class="line">        sptr=sptr-&gt;next;</span><br><span class="line">    &#125;<span class="keyword">while</span>(fptr!=sptr);</span><br><span class="line">    fptr=head;</span><br><span class="line">    <span class="keyword">while</span>(fptr!=sptr)&#123;</span><br><span class="line">        fptr=fptr-&gt;next;</span><br><span class="line">        sptr=sptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O(n)</p>
</li>
<li><p>空间复杂度：O(1)</p>
</li>
</ul>
</li>
</ul>
<h3 id="B-无向图最小环问题"><a href="#B-无向图最小环问题" class="headerlink" title="B. 无向图最小环问题"></a>B. 无向图最小环问题</h3><ul>
<li><p>细节</p>
<p>  当存在(u,v)边，我们可以知道u&lt;-&gt;v的最小距离为1。若u、v是一个环中的两个结点，显然删除当前边(u,v)仍能找到一个最短路，最小的圈就一定出现在这个最短路和这条边结合。依次删除边-&gt;最短路。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findShortestCycle</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> Dijkstra=[&amp;](vector&lt;set&lt;<span class="type">int</span>&gt;&gt;&amp;next,<span class="type">int</span> k) -&gt; vector&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">        <span class="type">int</span> n=next.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">dicts</span>(n,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;qu;</span><br><span class="line">        qu.<span class="built_in">push</span>(&#123;<span class="number">0</span>,k&#125;);</span><br><span class="line">        dicts[k]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> [d,u]=qu.<span class="built_in">top</span>();</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(dicts[u]&lt;d)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:next[u])&#123;</span><br><span class="line">                <span class="type">int</span> d1=d<span class="number">+1</span>;</span><br><span class="line">                <span class="keyword">if</span>(dicts[v]&gt;d1)&#123;</span><br><span class="line">                    qu.<span class="built_in">push</span>(&#123;d1,v&#125;);</span><br><span class="line">                    dicts[v]=d1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dicts;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;set&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">next</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:edges)&#123;</span><br><span class="line">        next[e[<span class="number">0</span>]].<span class="built_in">insert</span>(e[<span class="number">1</span>]);</span><br><span class="line">        next[e[<span class="number">1</span>]].<span class="built_in">insert</span>(e[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:edges)&#123;</span><br><span class="line">        next[e[<span class="number">0</span>]].<span class="built_in">erase</span>(e[<span class="number">1</span>]);</span><br><span class="line">        next[e[<span class="number">1</span>]].<span class="built_in">erase</span>(e[<span class="number">0</span>]);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;d=<span class="built_in">Dijkstra</span>(next,e[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(d[e[<span class="number">1</span>]]!=<span class="number">0x3f3f3f3f</span>)&#123;</span><br><span class="line">            res=<span class="built_in">min</span>(res,d[e[<span class="number">1</span>]]<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        next[e[<span class="number">0</span>]].<span class="built_in">insert</span>(e[<span class="number">1</span>]);</span><br><span class="line">        next[e[<span class="number">1</span>]].<span class="built_in">insert</span>(e[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res==INT_MAX?<span class="number">-1</span>:res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O($E^2logE$)</p>
</li>
<li><p>空间复杂度：O(E)</p>
</li>
</ul>
</li>
</ul>
<h3 id="C-有向图唯一环问题"><a href="#C-有向图唯一环问题" class="headerlink" title="C. 有向图唯一环问题"></a>C. 有向图唯一环问题</h3><ul>
<li><p>细节</p>
<p>  记录深搜路径，遇到已搜过的边即保证栈中从当前节点第一次出现到栈顶的元素都在环内。</p>
</li>
<li><p>实现例子</p>
<p>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/Za25hA/description/">https://leetcode.cn/problems/Za25hA/description/</a></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">chaseGame</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> startA, <span class="type">int</span> startB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 边数为顶点数且边不重复 -&gt; 一定有环</span></span><br><span class="line">    <span class="comment">// 环大小&gt;=3</span></span><br><span class="line">    <span class="comment">// 大小=3时一定能抓到</span></span><br><span class="line">    <span class="comment">// &gt;3的时候看谁离环近</span></span><br><span class="line">    <span class="type">int</span> n=edges.<span class="built_in">size</span>(),inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">next</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:edges)&#123;</span><br><span class="line">        next[e[<span class="number">0</span>]].<span class="built_in">push_back</span>(e[<span class="number">1</span>]);</span><br><span class="line">        next[e[<span class="number">1</span>]].<span class="built_in">push_back</span>(e[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到环</span></span><br><span class="line">    <span class="type">int</span> lcnt=<span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt;<span class="built_in">inloop</span>(n<span class="number">+1</span>),<span class="built_in">vis</span>(n<span class="number">+1</span>);</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;path;</span><br><span class="line">    function&lt;<span class="type">bool</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;dfs=[&amp;](<span class="type">int</span> u,<span class="type">int</span> pre)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[u])&#123;</span><br><span class="line">            <span class="comment">// 已经找到唯一闭环</span></span><br><span class="line">            inloop[u]=<span class="literal">true</span>;</span><br><span class="line">            lcnt++;</span><br><span class="line">            <span class="comment">// 找到第一次进入栈的点，之间的全是在环内</span></span><br><span class="line">            <span class="keyword">while</span>(!path.<span class="built_in">empty</span>()&amp;&amp;u!=path.<span class="built_in">top</span>())&#123;</span><br><span class="line">                inloop[path.<span class="built_in">top</span>()]=<span class="literal">true</span>;</span><br><span class="line">                lcnt++;</span><br><span class="line">                path.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        path.<span class="built_in">push</span>(u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:next[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(v!=pre&amp;&amp;<span class="built_in">dfs</span>(v,u))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A B到各点最短路</span></span><br><span class="line">    <span class="keyword">auto</span> bfs=[&amp;](<span class="type">int</span> s)-&gt;vector&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">res</span>(n<span class="number">+1</span>,inf);</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt;qu;</span><br><span class="line">        qu.<span class="built_in">push</span>(s);</span><br><span class="line">        res[s]=res[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> u=qu.<span class="built_in">front</span>();</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:next[u])&#123;</span><br><span class="line">                <span class="keyword">if</span>(res[v]==inf)&#123;</span><br><span class="line">                    res[v]=res[u]<span class="number">+1</span>;</span><br><span class="line">                    qu.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> As=<span class="built_in">bfs</span>(startA);</span><br><span class="line">    <span class="keyword">auto</span> Bs=<span class="built_in">bfs</span>(startB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看最远能到哪</span></span><br><span class="line">    <span class="type">int</span> maxi=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(As[i]-Bs[i]&gt;<span class="number">1</span>&amp;&amp;As[i]&gt;As[maxi])&#123;</span><br><span class="line">            maxi=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!maxi)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(lcnt&gt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inloop[startB])<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 能否进入环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inloop[i]&amp;&amp;As[i]-Bs[i]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> As[maxi];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> As[maxi];</span><br><span class="line">&#125;           </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="tarjan算法"><a href="#tarjan算法" class="headerlink" title="tarjan算法"></a>tarjan算法</h2><ul>
<li><p>细节</p>
<p>  根据以下条件维护：</p>
<ul>
<li><p>维护每一个顶点$u$的维护次序$dfn[u]$。</p>
</li>
<li><p>维护每一个顶点$u$的以其为根对应的搜索树的可到达最小$dfn[i]$为$low[u]$。</p>
<ul>
<li><p>对于其未遍历的子节点$v$对应的搜索树，其子树能到的最小$dfn[i]$，$u$也一定能到达，故有$low[u]&#x3D;min(low[u],low[v])$。</p>
</li>
<li><p>对于”[桥]已经维护过的且不是上一节点（进入节点）的子节点”或”[强连通]在栈中的元素”则为$low[u]&#x3D;min(low[u],dfn[v])$保证$low[i]$是尽可能不减的。</p>
</li>
</ul>
</li>
</ul>
<p>  可以发现以下性质：</p>
<ul>
<li><p><strong>[无向图]</strong> 若$u$的子节点$v$满足$dfn[u]&lt;low[v]$说明$v$节点之后的遍历的节点都是未曾遍历过的，说明这条边就是桥，桥上两根据情况判断是否为割点（$deg[i]&gt;1$？）。</p>
</li>
<li><p><strong>[有向图]</strong> 若节点$u$满足$dfn[u]&#x3D;&#x3D;low[u]$，则说明其与其子节点形成了一个强连通分支。</p>
</li>
</ul>
</li>
</ul>
<h3 id="A-桥-割点"><a href="#A-桥-割点" class="headerlink" title="A. 桥&#x2F;割点"></a>A. 桥&#x2F;割点</h3><ul>
<li><p>代码实现（以桥为例）</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">dfn</span>(n),<span class="built_in">low</span>(n);</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;tarjan=[&amp;](<span class="type">int</span> u,<span class="type">int</span> pre)&#123;</span><br><span class="line">    dfn[u]=low[u]=++cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:next[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v,u);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[u]&lt;low[v])&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;u,v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(v!=pre)&#123;</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">tarjan</span>(<span class="number">0</span>,<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O($m+n$)</p>
</li>
<li><p>空间复杂度：O($n$)</p>
</li>
</ul>
</li>
</ul>
<h3 id="B-强连通分支"><a href="#B-强连通分支" class="headerlink" title="B. 强连通分支"></a>B. 强连通分支</h3><ul>
<li><p>细节</p>
<p>  有向图没有不会产生无向图无法分辨父节点的情况，不必判断是否为父节点。</p>
<p>  引入$vis$标记节点是否在栈中，防止干扰。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;stk;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">dfn</span>(n),<span class="built_in">low</span>(n),<span class="built_in">col</span>(n);</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt;<span class="built_in">vis</span>(n);</span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;tarjan=[&amp;](<span class="type">int</span> u)&#123;</span><br><span class="line">    dfn[u]=low[u]=++cnt;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    stk.<span class="built_in">push</span>(u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:next[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v,u);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line">        ++sum;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            col[stk.<span class="built_in">top</span>()]=sum;</span><br><span class="line">            vis[stk.<span class="built_in">top</span>()]=<span class="literal">false</span>;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">tarjan</span>(<span class="number">0</span>,<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O($m+n$)</p>
</li>
<li><p>空间复杂度：O($n$)</p>
</li>
</ul>
</li>
</ul>
<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a><strong>数论</strong></h1><h2 id="1-生成质数问题"><a href="#1-生成质数问题" class="headerlink" title="1. 生成质数问题"></a>1. 生成质数问题</h2><ul>
<li><p>线性筛</p>
<ul>
<li><p>细节</p>
<p>  默认每一个数都是质数，而遍历到一个数的时候将它的倍数全部排除，即将他们标记为非质数。而这其中当 $i%primes[j]&#x3D;&#x3D;0$ 满足时可以退出，因为当一个数$ i $可以被 $primes[j]$ 整除，那么对于合数 $i⋅primes[j+1] $而言，它一定在后面遍历到 $(i&#x2F;primes[j])⋅primes[j+1]$ （这个数一定大于$i$）这个数的时候有$ (i&#x2F;primes[j])⋅primes[j+1]⋅primes[j]&#x3D;&#x3D;i⋅primes[j+1]$ 被标记，所以之后的标记都是会在之后进行的，这时候退出是安全的。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getPrimes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; primes;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">isPrime</span><span class="params">(n<span class="number">+1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime[i])primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;primes.<span class="built_in">size</span>()&amp;&amp;i*primes[j]&lt;=n;j++)&#123;</span><br><span class="line">            isPrime[i*primes[j]]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> primes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O(n)</p>
</li>
<li><p>空间复杂度：O(n)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-快速幂"><a href="#2-快速幂" class="headerlink" title="2. 快速幂"></a>2. 快速幂</h2><ul>
<li><p>细节</p>
<pre><code>  每次计算时，将其二分计算，使得时间对数减少。
</code></pre>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> num,<span class="type">long</span> <span class="type">long</span> n,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ret=(ret*num)%mod;</span><br><span class="line">        num%=mod;</span><br><span class="line">        num=(num*num)%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O(logn)</p>
</li>
<li><p>空间复杂度：O(1)</p>
</li>
</ul>
</li>
<li><p>应用</p>
<ul>
<li><p>乘法逆元</p>
<ul>
<li><p>$p$是素数</p>
<p>  根据费马小定理，当p为质数时下式成立。<br>  $$<br>  a^{p-1}\bmod p&#x3D;1<br>  $$<br>  之和可以推导出下式。<br>  $$<br>  a^{p-2}&#x3D;a^{-1}\<br>  a^{-1}&#x3D;a^{p-2}<br>  $$<br>  故可以用乘法来代替除法。</p>
</li>
<li><p>更一般的情况</p>
<p>  根据欧拉定理的推广，若$a$对于$n$存在逆元，有$a^{\varphi(n)}&#x3D;1 \mod n$。</p>
<p>  故有$a^{-1}&#x3D;a^{\varphi(n)-1} \mod n$</p>
<p>  其中<br>  $$<br>  \varphi(n)&#x3D;\left{\begin{matrix}<br>  n-1 &amp;&amp; n \ is \ prime\<br>  n\prod_{i}(1-\frac{1}{p_i}) &amp;&amp; n \ isn&#96;t \ prime \<br>  \end{matrix}\right.<br>  $$</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-快速乘"><a href="#3-快速乘" class="headerlink" title="3. 快速乘"></a>3. 快速乘</h2><ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">mul</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> y, <span class="type">long</span> <span class="type">long</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> t = (<span class="type">long</span> <span class="type">double</span>)x / mod * y;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)x * y - (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)t * mod;</span><br><span class="line">    <span class="keyword">return</span> (res + mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-最大公约数"><a href="#4-最大公约数" class="headerlink" title="4. 最大公约数"></a>4. 最大公约数</h2><h3 id="A-基本"><a href="#A-基本" class="headerlink" title="A. 基本"></a>A. 基本</h3><ul>
<li><p>细节</p>
<p>  利用辗转相除法，得到最大公约数。</p>
<p>  $$<br>  \left.\begin{matrix}<br>  a&gt;b \<br>  a \div b &#x3D; q \dots r  \Rightarrow  a&#x3D;bq+r  \Rightarrow  r&#x3D;a-bq\<br>  gcd(a,b)&#x3D;d \Rightarrow a&#x3D;dm,b&#x3D;dn\<br>  \end{matrix}\right}<br>  \Rightarrow r&#x3D;dm-dnq \Rightarrow r&#x3D;d(m-nq) \Rightarrow d|r\<br>  \Rightarrow gcd(a,b)&#x3D;&#x3D;gcd(b,r)<br>  $$</p>
<p>  b&#x3D;&#x3D;0 -&gt; 直接返回a<br>  b!&#x3D;0 -&gt; 计算b和a%b的最大公约数（当a&lt;b,操作等同于gcd(b,a)保证了计算的是a&gt;b的情况。）</p>
</li>
<li><p>实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        r=a%b;</span><br><span class="line">        a=b;</span><br><span class="line">        b=r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &gt; <span class="number">0</span> ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O(logn)</p>
</li>
<li><p>空间复杂度：O(1)&#x2F;O(logn)</p>
</li>
</ul>
</li>
</ul>
<h3 id="B-运用"><a href="#B-运用" class="headerlink" title="B. 运用"></a>B. 运用</h3><h4 id="a-裴蜀定理"><a href="#a-裴蜀定理" class="headerlink" title="a. 裴蜀定理"></a>a. 裴蜀定理</h4><p>$$<br>\gcd(x,y)&#x3D;d \Longrightarrow \exists{a、b},使得 (ax+by)\mod{d}&#x3D;0 \<br>\gcd(x,y)&#x3D;1 \Longrightarrow \exists{a、b},使得ax+by&#x3D;1<br>$$</p>
<p>对于n维来说同样成立。</p>
<p>$$<br>\gcd(x_{1},…,x_{n})&#x3D;1 \Longrightarrow \exists{a_{1},…,a_{n}},使得a_{1}x_{1}+…+anxn&#x3D;1<br>$$</p>
<ul>
<li><p>应用：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/check-if-it-is-a-good-array/">https://leetcode.cn/problems/check-if-it-is-a-good-array/</a></li>
</ul>
</li>
</ul>
<h2 id="5-分解质因数"><a href="#5-分解质因数" class="headerlink" title="5. 分解质因数"></a>5. 分解质因数</h2><h3 id="a-找到全部质因数及其数目"><a href="#a-找到全部质因数及其数目" class="headerlink" title="a. 找到全部质因数及其数目"></a>a. 找到全部质因数及其数目</h3><ul>
<li><p>细节</p>
<p>  能除就除，不能就跳过，非质数其因子一定被耗尽。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">divide</span>(<span class="type">int</span> n)&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">                n/=i;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(&#123;i,cnt&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="number">1</span>)ret.<span class="built_in">push_back</span>(&#123;n,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="b-计算1-n的乘积的某个质数的奉献"><a href="#b-计算1-n的乘积的某个质数的奉献" class="headerlink" title="b. 计算1~n的乘积的某个质数的奉献"></a>b. 计算1~n的乘积的某个质数的奉献</h3><ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="type">long</span> <span class="type">long</span>(<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>)&gt; getRes=[&amp;](<span class="type">long</span> <span class="type">long</span> num,<span class="type">int</span> p)-&gt;<span class="type">long</span> <span class="type">long</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;p)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num/p+<span class="built_in">getRes</span>(num/p,p);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-分解因子"><a href="#6-分解因子" class="headerlink" title="6. 分解因子"></a>6. 分解因子</h2><ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(i);</span><br><span class="line">        ret.<span class="built_in">push_back</span>(n/i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-二进制处理"><a href="#7-二进制处理" class="headerlink" title="7. 二进制处理"></a>7. 二进制处理</h2><p>可以使用bitset<N>来处理巨量的二进制数。</p>
<h3 id="A-快速获取二进制数1的数目"><a href="#A-快速获取二进制数1的数目" class="headerlink" title="A. 快速获取二进制数1的数目"></a>A. 快速获取二进制数1的数目</h3><ul>
<li><p>细节</p>
<p>  注意到 $ num&amp;(num-1) $ 将num的最低位1反转，其余不变。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numOf1</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">        res++;</span><br><span class="line">        num=num&amp;(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> numOf1=[&amp;](<span class="type">int</span> num)&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">        res++;</span><br><span class="line">        num=num&amp;(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="B-快速获取二进制子集"><a href="#B-快速获取二进制子集" class="headerlink" title="B. 快速获取二进制子集"></a>B. 快速获取二进制子集</h3><ul>
<li><p>细节</p>
<p>  枚举二进制数 $ (1011)<em>{B} $ 的子集形如 $ (1001)</em>{B} $ 、$ (1010)_{B} $ 的数字。其思路其实是和A差不多的。比起枚举并判断是否是其子集更快的方法。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> bit;</span><br><span class="line"><span class="comment">/* assign bit */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mask=bit;mask;mask=(mask<span class="number">-1</span>)&amp;bit)&#123;</span><br><span class="line">    <span class="comment">/* do somethings */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间复杂度：O($k \choose n$)，结合$2^n$将是$3^n$。</p>
</li>
</ul>
<h3 id="C-获取子集和数组"><a href="#C-获取子集和数组" class="headerlink" title="C. 获取子集和数组"></a>C. 获取子集和数组</h3><ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m=arr.<span class="built_in">sizze</span>(),_m=<span class="number">1</span>&lt;&lt;m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">sum</span>(_m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	<span class="type">int</span> bit=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">	sum[bit]=arr[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;bit;j++)&#123;</span><br><span class="line">		sum[bit|j]=arr[i]+sum[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="D-仅保留最右边1"><a href="#D-仅保留最右边1" class="headerlink" title="D. 仅保留最右边1"></a>D. 仅保留最右边1</h3><ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="E-格雷码编码"><a href="#E-格雷码编码" class="headerlink" title="E. 格雷码编码"></a>E. 格雷码编码</h3><ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">grayCode</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="number">1</span> &lt;&lt; n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        ret[i] = (i &gt;&gt; <span class="number">1</span>) ^ i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getGray</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="number">1</span> &lt;&lt; n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        ret[i] = (i &gt;&gt; <span class="number">1</span>) ^ i ^ start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="F-等效转换"><a href="#F-等效转换" class="headerlink" title="F. 等效转换"></a>F. 等效转换</h3><ul>
<li>$(x\ | \ y) -y&#x3D;x&amp;(\sim y)$</li>
</ul>
<h2 id="8-矩阵运算"><a href="#8-矩阵运算" class="headerlink" title="8. 矩阵运算"></a>8. 矩阵运算</h2><h3 id="A-矩阵乘法"><a href="#A-矩阵乘法" class="headerlink" title="A. 矩阵乘法"></a>A. 矩阵乘法</h3><ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> matrixMul = [&amp;](vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; a, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; b,<span class="type">int</span> mod)-&gt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="type">int</span> m = a.<span class="built_in">size</span>(), p = a[<span class="number">0</span>].<span class="built_in">size</span>(), n = b[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">res</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; p; ++k)&#123;</span><br><span class="line">                res[i][j] = ((ll)(a[i][k] % mod) * (b[k][j] % mod) + res[i][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            res[i][j] = (res[i][j] + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li>时间复杂度：O(mpn)</li>
</ul>
</li>
</ul>
<h3 id="B-矩阵快速幂"><a href="#B-矩阵快速幂" class="headerlink" title="B. 矩阵快速幂"></a>B. 矩阵快速幂</h3><ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;,<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>)&gt;pow=[&amp;](vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;matrix,<span class="type">long</span> <span class="type">long</span> k,<span class="type">int</span> mod)-&gt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&#123;</span><br><span class="line">	<span class="type">int</span> n=matrix.<span class="built_in">size</span>();</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">res</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		res[i][i]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(k)&#123;</span><br><span class="line">		<span class="keyword">if</span>(k%<span class="number">2</span>)&#123;</span><br><span class="line">			res=<span class="built_in">matrixMul</span>(res,matrix,mod);</span><br><span class="line">		&#125;</span><br><span class="line">		matrix=<span class="built_in">matrixMul</span>(matrix,matrix,mod);</span><br><span class="line">		k/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-n-n-的性质"><a href="#9-n-n-的性质" class="headerlink" title="9. $n^n$的性质"></a>9. $n^n$的性质</h2><ul>
<li><p>最右边一位 &#x3D;&gt; 快速幂mod取10</p>
</li>
<li><p>最左边一位 &#x3D;&gt; 对数性质</p>
<p>  $n^n&#x3D;10^{\log_{10}{n^n}}&#x3D;10^{n\log_{10}{n}}&#x3D;10^{N+s}&#x3D;10^N10^s$</p>
<p>  最高一位取决于$10^s$</p>
<p>  也即是$n\log_{10}{n}$的小数部分。</p>
</li>
</ul>
<h2 id="10-组合数-阶乘"><a href="#10-组合数-阶乘" class="headerlink" title="10. 组合数&#x2F;阶乘"></a>10. 组合数&#x2F;阶乘</h2><h3 id="维护方法"><a href="#维护方法" class="headerlink" title="维护方法"></a>维护方法</h3><ul>
<li><p>“+”法维护</p>
<p>  利用多数题目只需要利用扁平的组合数范围，可以直接递推维护。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">C</span>(N<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(M<span class="number">+1</span>));</span><br><span class="line">C[<span class="number">0</span>][<span class="number">0</span>]=C[<span class="number">1</span>][<span class="number">0</span>]=C[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">    C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(M,i);j++)&#123;</span><br><span class="line">        C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>“x”法维护</p>
<p>  利用多数题目限制对$mod$取模，可以选择维护乘法逆元。</p>
<p>  维护出需要的所有$A$，同时维护出所有对应的$A_f$，在需要的时候进行如下计算：</p>
<p>  ${n \choose m}&#x3D;\frac{n!}{m!(n-m)!}&#x3D;\frac{A[n]}{A[m]A[n-m]}&#x3D;A[n]A_f[m]A_f[n-m]$</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mod=,N=;</span><br><span class="line"><span class="keyword">auto</span> fpow=[&amp;](<span class="type">long</span> <span class="type">long</span> num,<span class="type">long</span> <span class="type">long</span> n,<span class="type">int</span> mod)&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ret=(ret*num)%mod;</span><br><span class="line">        num=(num*num)%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">A</span>(N<span class="number">+1</span>),<span class="built_in">Af</span>(N<span class="number">+1</span>);</span><br><span class="line">A[<span class="number">0</span>]=A[<span class="number">1</span>]=Af[<span class="number">0</span>]=Af[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">    A[i]=(i*A[i<span class="number">-1</span>])%mod;</span><br><span class="line">    Af[i]=<span class="built_in">fpow</span>(A[i],mod<span class="number">-2</span>,mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> nCm=[&amp;](<span class="type">int</span> n,<span class="type">int</span> m)&#123;</span><br><span class="line">    <span class="built_in">return</span> ((<span class="type">long</span> <span class="type">long</span>)(((<span class="type">long</span> <span class="type">long</span>)A[n]*Af[m])%mod)*Af[n-m])%mod;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>$n&gt;&gt;m$</p>
<p>  此时可以根据原来的等式，预处理所有$m$的阶乘的逆元，每次计算的时候计算$[n-m+1,n]$的乘积与$m$的阶乘的逆元相乘即得到答案。</p>
</li>
</ul>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><h4 id="A-隔板法"><a href="#A-隔板法" class="headerlink" title="A. 隔板法"></a>A. 隔板法</h4><p>将一些物品分配到一些地方的可能情况的数目。</p>
<ul>
<li><p>每个地方必须最少有一个</p>
<pre><code>   1 2 3 4 5 6 7        
   O O O O O O O
    1 2 3 4 5 6
</code></pre>
<p>  如上图，$n$个物品之间有$n-1$个隔板，若要分成$m$组，其意义相当于从$n-1$个隔板选择$m-1$个，这样能保证所有组都有。故答案为${n-1 \choose m-1}$。</p>
</li>
<li><p>有的地方可以没有物品</p>
<p>  $n$个物品分为$m$组，有的组可以不放，这个问题可以转化为先给物品加入$m-1$个“空物品”，这样问题就变为了${n+m-1 \choose m-1}&#x3D;{n+m-1 \choose n}$</p>
</li>
</ul>
<h2 id="11-向量求解"><a href="#11-向量求解" class="headerlink" title="11. 向量求解"></a>11. 向量求解</h2><h5 id="a-两点与半径求圆心"><a href="#a-两点与半径求圆心" class="headerlink" title="a. 两点与半径求圆心"></a>a. 两点与半径求圆心</h5><p>$\mathbf{a}&#x3D;(ax,ay),\mathbf{b}&#x3D;(bx,by),r$</p>
<ul>
<li><p>分析</p>
<ul>
<li>找出中点向量$\mathbf{mid}&#x3D;((ax+bx)&#x2F;2,(ay+by)&#x2F;2))$</li>
<li>易得$\mathbf{ab}&#x3D;(bx-ax,by-ay)$</li>
<li>找到垂线向量$\mathbf{h}&#x3D;(ay-by,bx-ax)*\sqrt{r^2-(\frac{|ab|}{2})^2}&#x2F;|(ay-by,bx-ax)|$</li>
<li>易得$\mathbf{r}&#x3D;\mathbf{h}+\mathbf{mid}$</li>
</ul>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> getR=[&amp;](<span class="type">double</span> ax,<span class="type">double</span> ay,<span class="type">double</span> bx,<span class="type">double</span> by,<span class="type">double</span> r)-&gt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&#123;</span><br><span class="line">    <span class="type">double</span> d=(ax*ax+bx*bx);</span><br><span class="line">    <span class="type">double</span> midx=(ax+bx)/<span class="number">2.0</span>,midy=(ay+by)/<span class="number">2.0</span>;</span><br><span class="line">    <span class="type">double</span> abx=bx-ax,aby=by-ay;</span><br><span class="line">    <span class="type">double</span> h_len=<span class="built_in">sqrt</span>(r*r-(abx*abx+aby*aby)/<span class="number">4.0</span>);</span><br><span class="line">    <span class="type">double</span> hx=ay-by,hy=bx-ax;</span><br><span class="line">    <span class="type">double</span> hd=<span class="built_in">sqrt</span>(hx*hx+hy*hy);</span><br><span class="line">    hx/=hd,hy/=hd;</span><br><span class="line">    hx*=h_len,hy*=h_len;</span><br><span class="line">    <span class="keyword">return</span> &#123;hx+midx,hy+midy&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="b-角度相关"><a href="#b-角度相关" class="headerlink" title="b. 角度相关"></a>b. 角度相关</h5><ul>
<li><p>向量求解</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">Sub</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;a.first-b.first,a.second-b.second&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>向量叉乘</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Cross</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.first*b.second-a.second*b.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="12-整数分解"><a href="#12-整数分解" class="headerlink" title="12. 整数分解"></a>12. 整数分解</h2><h3 id="a-分解为两个相邻整数构成的最小集合"><a href="#a-分解为两个相邻整数构成的最小集合" class="headerlink" title="a. 分解为两个相邻整数构成的最小集合"></a>a. 分解为两个相邻整数构成的最小集合</h3><ul>
<li><p>分析</p>
<p>  设设整数为<code>num</code>，相邻的两个整数为<code>i</code>、<code>i+1</code>，按照以下步骤找到的数可能最小：</p>
<ol>
<li><p>令$d&#x3D;num&#x2F;(i+1)$、$r&#x3D;num%(i+1)$</p>
<p> 如果$r&#x3D;&#x3D;0$，已经构成所需集合：$d$</p>
<p> 如果$r+d&gt;&#x3D;num$我们凑出新的一项以构成所需集合：$d+1$</p>
</li>
<li><p>令$d&#x3D;num&#x2F;i$、$r&#x3D;num%i$</p>
<p> 如果$r&#x3D;&#x3D;0$，已经构成所需集合：$d$</p>
<p> 如果$r&lt;&#x3D;d$我们可以将余数放入已有的数：$d$</p>
</li>
</ol>
</li>
</ul>
<h2 id="13-绝对值最值问题"><a href="#13-绝对值最值问题" class="headerlink" title="13. 绝对值最值问题"></a>13. 绝对值最值问题</h2><h3 id="a-哈密顿距离最大"><a href="#a-哈密顿距离最大" class="headerlink" title="a. 哈密顿距离最大"></a>a. 哈密顿距离最大</h3><ul>
<li><p>分析</p>
<p>  存在若干个点，求最大的哈密顿距离$∣x_i−x_j∣+∣y_i−y_j∣$点对。</p>
<p>  问题转变为：<br>  $$<br>  \begin{aligned}<br>  &amp;\max{∣x_i−x_j∣+∣y_i−y_j∣}\<br>  &amp;&#x3D;max{x_i-x_j,x_j-x_i}+max{y_i-y_j,y_j-y_i} \<br>  &amp;&#x3D;max{x_i-x_j+y_i-y_j,x_i-x_j+y_j-y_i,x_j-x_i+y_i-y_j,x_j-x_i+y_j-y_i} \<br>  &amp;&#x3D;max{x_i+y_i-(x_j+y_j),x_i-y_i-(x_j-y_j),x_j-y_j-(x_i-y_i),x_j+y_j-(x_i+y_i)}\<br>  &amp;&#x3D;max{|x_i+y_i-(x_j+y_j)|,|x_i-y_i-(x_j-y_j|}\<br>  &amp;&#x3D;max(max{x_i+y_i}-min{x_i+y_i},max{x_i-y_i}-min{x_i-y_i})<br>  \end{aligned}<br>  $$</p>
</li>
<li><p>例题</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimize-manhattan-distances/description/">最小化曼哈顿距离</a></p>
<p>  使用有序集合完成对最大距离的维护，同时此题也可以维护最大、次大、最小、次小来完成维护删除1节点的情况。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumDistance</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=points.<span class="built_in">size</span>();</span><br><span class="line">    set&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;add,sub;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        add.<span class="built_in">insert</span>(&#123;points[i][<span class="number">0</span>]+points[i][<span class="number">1</span>],i&#125;);</span><br><span class="line">        sub.<span class="built_in">insert</span>(&#123;points[i][<span class="number">0</span>]-points[i][<span class="number">1</span>],i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=points[i][<span class="number">0</span>],y=points[i][<span class="number">1</span>];</span><br><span class="line">        add.<span class="built_in">erase</span>(&#123;x+y,i&#125;);</span><br><span class="line">        sub.<span class="built_in">erase</span>(&#123;x-y,i&#125;);</span><br><span class="line">        res=<span class="built_in">min</span>(res,<span class="built_in">max</span>(add.<span class="built_in">rbegin</span>()-&gt;first-add.<span class="built_in">begin</span>()-&gt;first,sub.<span class="built_in">rbegin</span>()-&gt;first-sub.<span class="built_in">begin</span>()-&gt;first));</span><br><span class="line">        add.<span class="built_in">insert</span>(&#123;x+y,i&#125;);</span><br><span class="line">        sub.<span class="built_in">insert</span>(&#123;x-y,i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="14-中国剩余定律"><a href="#14-中国剩余定律" class="headerlink" title="14. 中国剩余定律"></a>14. 中国剩余定律</h2><ul>
<li><p>问题重述</p>
<p>  求出满足下式的最小$x$。</p>
<p>  $$<br>  \left{\begin{matrix}<br>  x \mod m_1 &#x3D; a_1 \<br>  x \mod m_2 &#x3D; a_2 \<br>  … \<br>  x \mod m_n &#x3D; a_n \<br>  \end{matrix}\right. \<br>  gcd(m_i,m_j)&#x3D;1, where \ i \neq \ j<br>  $$</p>
</li>
<li><p>分析</p>
<p>  采用逐级满足法。$M&#x3D;\prod_{i&#x3D;1}^n{m_i}$，$M_i&#x3D;\frac{\prod_{i&#x3D;1}^n{m_i}}{m_i}$。<br>  $$<br>  e_i &#x3D; M_i^{-1} \mod m_i \<br>  x &#x3D; \sum_{i&#x3D;1}^n{a_iM_ie_i} \mod M<br>  $$<br>  留意到$M_i$一定与$m_i$互素，这说明$e_i$一定存在，可以用欧拉定理等求出该逆元。</p>
</li>
</ul>
<h2 id="15-容斥定理"><a href="#15-容斥定理" class="headerlink" title="15. 容斥定理"></a>15. 容斥定理</h2><h3 id="a-倍数问题"><a href="#a-倍数问题" class="headerlink" title="a. 倍数问题"></a>a. 倍数问题</h3><ul>
<li><p>问题重述</p>
<p>  求一个数字<code>num</code>判断其是在已知不重数据集<code>list</code>所产生的所有整数倍的数字中小于<code>num</code>的数目。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">getRes</span><span class="params">(<span class="type">long</span> <span class="type">long</span> num, vector&lt;<span class="type">int</span>&gt;&amp;list)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n=list.<span class="built_in">size</span>();</span><br><span class="line">    function&lt;<span class="type">long</span> <span class="type">long</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">long</span> <span class="type">long</span>,<span class="type">long</span> <span class="type">long</span>)&gt;get=[&amp;](<span class="type">int</span> idx,<span class="type">int</span> num,<span class="type">long</span> <span class="type">long</span> cur,<span class="type">long</span> <span class="type">long</span> m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> m/cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(idx==n)<span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get</span>(idx<span class="number">+1</span>,num<span class="number">-1</span>,<span class="built_in">lcm</span>(cur,list[idx]),m)+<span class="built_in">get</span>(idx<span class="number">+1</span>,num,cur,m);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        res+=<span class="built_in">get</span>(<span class="number">0</span>,i,<span class="number">1</span>,num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="16-逻辑操作性质"><a href="#16-逻辑操作性质" class="headerlink" title="16. 逻辑操作性质"></a>16. 逻辑操作性质</h2><ul>
<li><p>描述</p>
<p>  对<code>and</code>,<code>or</code>,<code>gcd()</code>,<code>lcm()</code>操作，最多有<code>log(U)</code>个不同的值（值对应的位置并不满足）。</p>
</li>
<li><p>利用</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-sum-of-values-by-dividing-array/">划分数组得到最小的值之和</a></p>
<ul>
<li><p>细节</p>
<p>  利用本性质，最多有<code>O(nmlogU)</code>个状态。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m,inf;</span><br><span class="line">unordered_map&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt;mem;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRes</span><span class="params">(<span class="type">int</span> idx,<span class="type">int</span> num,<span class="type">int</span> x,vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">int</span>&gt;&amp; andValues)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n-idx&lt;m-num)&#123;</span><br><span class="line">        <span class="keyword">return</span> inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx==n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inf;</span><br><span class="line">    &#125;</span><br><span class="line">    x&amp;=nums[idx];</span><br><span class="line">    <span class="keyword">if</span>(x&lt;andValues[num])&#123;</span><br><span class="line">        <span class="keyword">return</span> inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mask=((<span class="type">long</span> <span class="type">long</span>)idx&lt;&lt;<span class="number">36</span>)|((<span class="type">long</span> <span class="type">long</span>)num&lt;&lt;<span class="number">32</span>)|x;</span><br><span class="line">    <span class="keyword">if</span>(mem.<span class="built_in">count</span>(mask))&#123;</span><br><span class="line">        <span class="keyword">return</span> mem[mask];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="built_in">getRes</span>(idx<span class="number">+1</span>,num,x,nums,andValues);</span><br><span class="line">    <span class="keyword">if</span>(x==andValues[num])&#123;</span><br><span class="line">        res=<span class="built_in">min</span>(res,<span class="built_in">getRes</span>(idx<span class="number">+1</span>,num<span class="number">+1</span>,<span class="number">-1</span>,nums,andValues)+nums[idx]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mem[mask]=res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumValueSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; andValues)</span> </span>&#123;</span><br><span class="line">    n=nums.<span class="built_in">size</span>(),m=andValues.<span class="built_in">size</span>(),inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="built_in">getRes</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,nums,andValues);</span><br><span class="line">    <span class="keyword">return</span> res==inf?<span class="number">-1</span>:res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h1><h2 id="1-字符串匹配算法KMP"><a href="#1-字符串匹配算法KMP" class="headerlink" title="1. 字符串匹配算法KMP"></a>1. 字符串匹配算法KMP</h2><ul>
<li><p>细节</p>
<pre><code>  每次比较失效时会仅移动模式串P的指针而移动主串T的指针，减少无效对比。每次失效的时候，查找next数组，寻找模式串下一个应该在的位置。
  
      0 1 2 3 4 5 6 7 8 9              0 1 2 3 4 5 6 7 8 9
  P   = = - - = = X - -           -&gt;           = = ? - = = - - -      
  T   - - - - - - - - - - - - -   -&gt;   - - - - - - - - - - - - -
  
  当模式串在比较下标6位置出现失配时，假定6下标位置前面两个字符与模式串前两个字符一致，那就可以如上图一样移动模式串再次比较。这个next[6]存储的就是当P[6]!=T[6]时，模式串的指针应该移动到哪里？这个问题的答案其实就是不重叠前后缀最大时前缀最后一个元素的后一个元素的位置。这样可以令主串T的指针不用来回走。
  
  实际例子：
  
          0 1 2 3 4 5 6 7 8 9
  P     * A B A A B C A B A D
  
  next   -1 0 0 1 1 2 0 1 2 3 0
</code></pre>
<p>  $$<br>  \begin{aligned}<br>  next[j] &#x3D;<br>  \left{ \begin{matrix}\begin{aligned}&amp;-1&amp;,j&#x3D;0 \<br>  &amp;max{k|p[0:k-1]&#x3D;p[j-k+1:j]}&amp;,k\ne\emptyset \<br>  &amp;0&amp;,other<br>  \end{aligned}<br>  \end{matrix}<br>  \right.<br>  \end{aligned}<br>  $$</p>
<pre><code>  我们假设P[-1]是一个通配符，可与任何字符作配对。P[0]错了就需要将本次比较的这个地方的字符与*作配对，所以next[0]=-1。假设正在计算next[j]，k=next[j-1]，如果P[k]==P[j-1]那就直接是next[j]=k+1，因为P[0:k-1]严格等于P[j-1-k:j-2]；当P[k]!=P[j-1]可以预见的是前缀和后缀要相等就不能那么长了，但我们由于上一次的k还相对大，P[0:k-1]严格等于P[j-1-k:j-2]，k变小仍满足，故k回退到next[k]（为什么对？见下图），再次比较，最终得到可以满足P[k]==P[j-1]的k，完成求解（注意边界k==-1）。
  
           K       j-1               next[k]
           |        |                  |
  S -&gt; [S1]X[--][S2]O      S1 -&gt; [S1_1]X[--][S1_2]      S2 -&gt; [S2_1]X[--][S2_2]
  
  一定有S1==S2，故S1_2==S2_2，故找到next[k]作为下一次的比较对象是安全的，[S1_1]与next[k]对应的X以及[S2_2]与j-1对应的O正是这个子序列的前缀和后缀。
</code></pre>
</li>
<li><p>代码实现</p>
<ul>
<li><p>next数组(找最大相同前后缀问题)</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_KMP_next</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="comment">//ptr维护j-1 prek维护上一个k</span></span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">size</span>(),ptr=<span class="number">0</span>,prek=<span class="number">-1</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">ret</span>(n<span class="number">+1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">while</span>(ptr&lt;n)&#123;</span><br><span class="line">        <span class="comment">//遇到通配符或者是得到配对</span></span><br><span class="line">        <span class="keyword">if</span>(prek==<span class="number">-1</span>||s[ptr]==s[prek])&#123;</span><br><span class="line">            ret[++ptr]=++prek;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//寻找上一个k</span></span><br><span class="line">        <span class="keyword">else</span> prek=ret[prek];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> get_next=[&amp;](string _str)-&gt;vector&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="type">int</span> _n=_str.<span class="built_in">size</span>(),_ptr=<span class="number">0</span>,_prek=<span class="number">-1</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;_ret(_n<span class="number">+1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">while</span>(_ptr&lt;_n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(_prek==<span class="number">-1</span>||_str[_ptr]==_str[_prek])&#123;</span><br><span class="line">            _ret[++_ptr]=++_prek;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        	_prek=_ret[_prek]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用next数组完成查找</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_KMP</span><span class="params">(string t,string p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tptr=<span class="number">0</span>,pptr=<span class="number">0</span>,tn=t.<span class="built_in">size</span>(),pn=p.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;next=<span class="built_in">get_KMP_next</span>(p);</span><br><span class="line">    <span class="keyword">while</span>(tptr&lt;tn&amp;&amp;pptr&lt;pn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pptr&lt;<span class="number">0</span>||t[tptr]==p[pptr])&#123;</span><br><span class="line">            tptr++,pptr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pptr=next[pptr];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pptr==pn)<span class="keyword">return</span> tptr-pn;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>封装</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getIndex</span><span class="params">(string t,string p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tptr=<span class="number">0</span>,pptr=<span class="number">0</span>,tn=t.<span class="built_in">size</span>(),pn=p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">auto</span> get_next=[&amp;](string _str)-&gt;vector&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">        <span class="type">int</span> _n=_str.<span class="built_in">size</span>(),_ptr=<span class="number">0</span>,_prek=<span class="number">-1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;_ret(_n<span class="number">+1</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>(_ptr&lt;_n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(_prek==<span class="number">-1</span>||_str[_ptr]==_str[_prek])&#123;</span><br><span class="line">                _ret[++_ptr]=++_prek;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            _prek=_ret[_prek]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _ret;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;next=<span class="built_in">get_next</span>(p);</span><br><span class="line">    <span class="keyword">while</span>(tptr&lt;tn&amp;&amp;pptr&lt;pn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pptr&lt;<span class="number">0</span>||t[tptr]==p[pptr])&#123;</span><br><span class="line">            tptr++,pptr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pptr=next[pptr];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pptr==pn)<span class="keyword">return</span> tptr-pn;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>取得匹配次数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> getMatchNum=[&amp;](string t,string p)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">    <span class="type">int</span> tptr=<span class="number">0</span>,pptr=<span class="number">0</span>,tn=t.<span class="built_in">size</span>(),pn=p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">auto</span> get_next=[&amp;](string _str)-&gt;vector&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">        <span class="type">int</span> _n=_str.<span class="built_in">size</span>(),_ptr=<span class="number">0</span>,_prek=<span class="number">-1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;_ret(_n<span class="number">+1</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>(_ptr&lt;_n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(_prek==<span class="number">-1</span>||_str[_ptr]==_str[_prek])&#123;</span><br><span class="line">                _ret[++_ptr]=++_prek;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                _prek=_ret[_prek]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _ret;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;next=<span class="built_in">get_next</span>(p);</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tptr&lt;tn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pptr&lt;<span class="number">0</span>||(pptr&lt;pn&amp;&amp;t[tptr]==p[pptr]))&#123;</span><br><span class="line">            tptr++,pptr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(pptr==pn)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            pptr=next[pptr];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pptr==pn)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>取得所有相同前后缀</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt;res;</span><br><span class="line"><span class="keyword">auto</span> next=<span class="built_in">get_next</span>(word);</span><br><span class="line"><span class="type">int</span> n=word.<span class="built_in">size</span>(),t=next;</span><br><span class="line">res.<span class="built_in">insert</span>(n);</span><br><span class="line"><span class="keyword">while</span>(t)&#123;</span><br><span class="line">    res.<span class="built_in">insert</span>(t);</span><br><span class="line">    t=next[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度： O($n+m$)</p>
</li>
<li><p>空间复杂度： O($m$)</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-扩展KMP（Z函数）"><a href="#2-扩展KMP（Z函数）" class="headerlink" title="2. 扩展KMP（Z函数）"></a>2. 扩展KMP（Z函数）</h2><ul>
<li><p>细节</p>
<p>  定义对于个长度为$n$的字符串$s$。定义函数$z[i]$表示$s$和$s[i:n]$（即以$s[i]$开头的后缀）的最长公共前缀（LCP）的长度。$z$被称为$s$的 <strong>Z 函数</strong>。<strong>特别地，$z[0]&#x3D;0$。</strong></p>
<p>  维护$l,r$使得$s[l:r+1]$是$s$的前缀（即$s[l:r+1]&#x3D;&#x3D;s[0:r+1-l]$）且$[l,r]$在包含$i$的情况下需要$r$尽可能大。$[l,r]$被称为Z-Box。</p>
<ul>
<li>如果$i&lt;&#x3D;r$有$s[i:r+1]&#x3D;&#x3D;s[i-l:r+1-l]$（因为有$s[l:r+1]&#x3D;&#x3D;s[0:r+1-l]$）,故有$z[i]&gt;&#x3D;min(z[i-l],r-i+1)$（与$s[i-l:n]$的前缀只能保证有$r-i+1$个字符一致）。<ul>
<li>$z[i-l]&lt;r-i+1$可以直接得到$z[i]&#x3D;z[i-l]$</li>
<li>$z[i-l]&gt;&#x3D;r-i+1$需要再枚举检查。</li>
</ul>
</li>
<li>如果$i&gt;r$直接枚举检查。</li>
<li>最终维护新的$l,r$，如果右端能取到更远即$i+z[i]-1&gt;r$则维护其分别为$l&#x3D;i,r&#x3D;i+z[i]-1$。</li>
</ul>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> getZ=[&amp;](string _str)-&gt;vector&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line">    <span class="type">int</span> n=_str.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">z</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=r&amp;&amp;z[i-l]&lt;r-i<span class="number">+1</span>)&#123;</span><br><span class="line">            z[i]=z[i-l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            z[i]=<span class="built_in">max</span>(<span class="number">0</span>,r-i<span class="number">+1</span>);</span><br><span class="line">            <span class="keyword">while</span>(i+z[i]&lt;n&amp;&amp;_str[z[i]]==_str[i+z[i]])z[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i+z[i]<span class="number">-1</span>&gt;r)&#123;</span><br><span class="line">            l=i,r=i+z[i]<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
<li><p>分析</p>
<ul>
<li>时间复杂度：O($n$)</li>
</ul>
</li>
</ul>
<h2 id="3-回文串"><a href="#3-回文串" class="headerlink" title="3. 回文串"></a>3. 回文串</h2><h3 id="A-快速判断某区间是否回文串"><a href="#A-快速判断某区间是否回文串" class="headerlink" title="A. 快速判断某区间是否回文串"></a>A. 快速判断某区间是否回文串</h3><ul>
<li><p>细节</p>
<p>  二维动态规划，$dp[i][j]&#x3D;dp[i+1][j-1]&amp;&amp;s[i]&#x3D;&#x3D;s[j]$来解决。</p>
</li>
</ul>
<h3 id="B-区间最大回文子序列"><a href="#B-区间最大回文子序列" class="headerlink" title="B. 区间最大回文子序列"></a>B. 区间最大回文子序列</h3><ul>
<li><p>细节</p>
<p>  二维动态规划，$dp[i][j]&#x3D;max(dp[i+1][j-1]+2,dp[i+1][j],dp[i][j-1])$。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    dp[i][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">            dp[i][j]=dp[i<span class="number">+1</span>][j<span class="number">-1</span>]<span class="number">+2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">+1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="C-只需要最长的回文串（manacher算法）"><a href="#C-只需要最长的回文串（manacher算法）" class="headerlink" title="C. 只需要最长的回文串（manacher算法）"></a>C. 只需要最长的回文串（manacher算法）</h3><ul>
<li><p>细节</p>
<ul>
<li><p>加入’#’来确保每一个回文串的长度都是奇数，不需要奇数偶数分来讨论。</p>
</li>
<li><p>如果当前位置是之前半径范围内 -&gt; 查看上一次半径中心为中心点的对称位置 -&gt; 找到不需要对比的最大边界。</p>
<p>  注意：由于包含于中心，K与X是对称关系，所以有X的臂长与K的臂长有相关，但这个相关性在超出端点时失效，故有个上界$right-i$。</p>
<pre><code>  ====O=======K======O======X=======O====
      |       |      |	  |       |
    2j-r     2j-i    j      i       r
   (左端点) (对称点) (中心) (当前)  (右端点) 
             i_sym                 right
</code></pre>
</li>
<li><p>如果不在之前半径范围内 -&gt; 对当前位置进行扩张</p>
</li>
</ul>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">expand</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">size</span>() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">        --left;</span><br><span class="line">        ++right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (right - left - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">-1</span>;</span><br><span class="line">    string t = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c: s) &#123;</span><br><span class="line">        t += c;</span><br><span class="line">        t += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    s = t;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arm_len;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">-1</span>, j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> cur_arm_len;</span><br><span class="line">        <span class="keyword">if</span> (right &gt;= i) &#123;</span><br><span class="line">            <span class="comment">// 包含于上一次的回文串</span></span><br><span class="line">            <span class="comment">// 找出对称点找到不用验证的最大臂长</span></span><br><span class="line">            <span class="type">int</span> i_sym = j * <span class="number">2</span> - i;</span><br><span class="line">            <span class="type">int</span> min_arm_len = <span class="built_in">min</span>(arm_len[i_sym], right - i);</span><br><span class="line">            <span class="comment">// 以i为中心以及刚才得出的臂长进行扩展</span></span><br><span class="line">            cur_arm_len = <span class="built_in">expand</span>(s, i - min_arm_len, i + min_arm_len);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 于上一个回文串相斥</span></span><br><span class="line">            <span class="comment">// 以i为中心扩展</span></span><br><span class="line">            cur_arm_len = <span class="built_in">expand</span>(s, i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        arm_len.<span class="built_in">push_back</span>(cur_arm_len);</span><br><span class="line">        <span class="comment">// 维护到延伸最长的中心与距离</span></span><br><span class="line">        <span class="keyword">if</span> (i + cur_arm_len &gt; right) &#123;</span><br><span class="line">            j = i;</span><br><span class="line">            right = i + cur_arm_len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 维护答案</span></span><br><span class="line">        <span class="keyword">if</span> (cur_arm_len * <span class="number">2</span> + <span class="number">1</span> &gt; end - start) &#123;</span><br><span class="line">            start = i - cur_arm_len;</span><br><span class="line">            end = i + cur_arm_len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            ans += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O(n)</p>
</li>
<li><p>空间复杂度：O(n)</p>
</li>
</ul>
</li>
<li><p>更多例子</p>
<ul>
<li><p>两个回文子字符串长度的最大乘积</p>
<p>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-product-of-the-length-of-two-palindromic-substrings/">https://leetcode.cn/problems/maximum-product-of-the-length-of-two-palindromic-substrings/</a></p>
<ul>
<li><p>细节</p>
<p>  本题需要的是奇数的回文串，所以不用加’#’。</p>
<p>  同时本题计算左右最大回文串时使用了先<code>rmax[i]=max(rmax[i+1],rmax[i])</code>，再进行<code>rmax[i]=max(rmax[i-1]-2,rmax[i])</code>的操作，也十分巧妙。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxProduct</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> expand=[&amp;](<span class="type">const</span> string&amp;s,<span class="type">int</span> left,<span class="type">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;s.<span class="built_in">size</span>()&amp;&amp;s[left]==s[right])&#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>(right-left<span class="number">-2</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">arm_len</span>(n);</span><br><span class="line">    <span class="type">int</span> right=<span class="number">-1</span>,j=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="type">int</span> cur_arm_len;</span><br><span class="line">        <span class="keyword">if</span>(right&gt;=i) &#123;</span><br><span class="line">            <span class="type">int</span> i_sym=j*<span class="number">2</span>-i;</span><br><span class="line">            <span class="type">int</span> min_arm_len=<span class="built_in">min</span>(arm_len[i_sym],right-i);</span><br><span class="line">            cur_arm_len=<span class="built_in">expand</span>(s,i-min_arm_len,i+min_arm_len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur_arm_len=<span class="built_in">expand</span>(s,i,i);</span><br><span class="line">        &#125;</span><br><span class="line">        arm_len[i]=cur_arm_len;</span><br><span class="line">        <span class="keyword">if</span>(i+cur_arm_len&gt;right)&#123;</span><br><span class="line">            j=i;</span><br><span class="line">            right=i+cur_arm_len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">lmax</span>(n),<span class="built_in">rmax</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        lmax[i+arm_len[i]]=<span class="built_in">max</span>(lmax[i+arm_len[i]],arm_len[i]*<span class="number">2</span><span class="number">+1</span>);</span><br><span class="line">        rmax[i-arm_len[i]]=<span class="built_in">max</span>(rmax[i-arm_len[i]],arm_len[i]*<span class="number">2</span><span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        rmax[i]=<span class="built_in">max</span>(rmax[i<span class="number">+1</span>],rmax[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        rmax[i]=<span class="built_in">max</span>(rmax[i<span class="number">-1</span>]<span class="number">-2</span>,rmax[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        lmax[i]=<span class="built_in">max</span>(lmax[i<span class="number">-1</span>],lmax[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        lmax[i]=<span class="built_in">max</span>(lmax[i<span class="number">+1</span>]<span class="number">-2</span>,lmax[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        res=<span class="built_in">max</span>(res,(<span class="type">long</span> <span class="type">long</span>)lmax[i]*rmax[i<span class="number">+1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="D-区间最大回文子串"><a href="#D-区间最大回文子串" class="headerlink" title="D. 区间最大回文子串"></a>D. 区间最大回文子串</h3><ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    dp[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">            dp[i][j]=dp[i<span class="number">+1</span>][j<span class="number">-1</span>]<span class="number">+2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">+1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-最大公共前缀LCP"><a href="#4-最大公共前缀LCP" class="headerlink" title="4. 最大公共前缀LCP"></a>4. 最大公共前缀LCP</h2><ul>
<li><p>细节</p>
<p>  二维动态规划，$dp[i][j]&#x3D;dp[i+1][j+1]+1\ when \ s[i]&#x3D;&#x3D;s[j] $来解决。</p>
</li>
</ul>
<h1 id="二分查找-折半查找"><a href="#二分查找-折半查找" class="headerlink" title="二分查找&#x2F;折半查找"></a><strong>二分查找&#x2F;折半查找</strong></h1><h2 id="1-查找一个内容的上界"><a href="#1-查找一个内容的上界" class="headerlink" title="1. 查找一个内容的上界"></a>1. 查找一个内容的上界</h2><p>upper_bound，第一个大于查找元素的位置。</p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">upper_bound</span><span class="params">(<span class="type">int</span> LOW,<span class="type">int</span> HIGH,<span class="type">int</span> target,vector&lt;<span class="type">int</span>&gt;&amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=LOW,r=HIGH;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(r-l)/<span class="number">2</span>+l;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid]&lt;=target)&#123;</span><br><span class="line">            l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-查找一个内容的下界"><a href="#2-查找一个内容的下界" class="headerlink" title="2. 查找一个内容的下界"></a>2. 查找一个内容的下界</h2><p>lower_bound，第一个大于等于的查找元素的位置。</p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(<span class="type">int</span> LOW,<span class="type">int</span> HIGH,<span class="type">int</span> target,vector&lt;<span class="type">int</span>&gt;&amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=LOW,r=HIGH;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(r-l)/<span class="number">2</span>+l;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid]&lt;target)&#123;</span><br><span class="line">            l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-查找单调函数的零点"><a href="#3-查找单调函数的零点" class="headerlink" title="3. 查找单调函数的零点"></a>3. 查找单调函数的零点</h2><ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> check=[&amp;](<span class="type">int</span> num)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/* */</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> l=LOW,r=HIGH;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="type">int</span> mid=(r-l)/<span class="number">2</span>+l;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid))r=mid;</span><br><span class="line">    <span class="keyword">else</span> l=mid<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这里mid偏l所以不会有无限循环风险。当mid成立的时候可能是答案，所以mid需要保留，当mid不成立的时候mid不必保留。</p>
</li>
</ul>
<h2 id="4-查找凹凸函数的极值点"><a href="#4-查找凹凸函数的极值点" class="headerlink" title="4. 查找凹凸函数的极值点"></a>4. 查找凹凸函数的极值点</h2><p>以凸函数为例。</p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> calculate=[&amp;](<span class="type">int</span> num)&#123;</span><br><span class="line">    <span class="comment">/* */</span></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> l=LOW,r=HIGH;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">calculate</span>(mid)&gt;<span class="built_in">calculate</span>(mid<span class="number">+1</span>))r=mid;</span><br><span class="line">    <span class="keyword">else</span> l=mid<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  不断靠近最大值。</p>
</li>
</ul>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a><strong>排序算法</strong></h1><h2 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1. 插入排序"></a>1. 插入排序</h2><p>插入排序一次排序中不一定能使一个元素到达它最终位置！</p>
<h3 id="A-直接插入排序"><a href="#A-直接插入排序" class="headerlink" title="A. 直接插入排序"></a>A. 直接插入排序</h3><ul>
<li><p>细节</p>
<pre><code>  每次将下一个元素插入前面已经有序的序列，每一次都能获得记录数+1的有序表。一个元素已经有序，所以不必再进行插入，可以直接从第二个元素开始。0号元素可以作为哨兵使用，每次将下一个元素插入前可以将这个元素先拷贝一份到哨兵位置，这样一定有匹配的地方。
</code></pre>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="comment">//arr从1号位置开始存储信息</span></span><br><span class="line">    <span class="comment">//arr.size()这里应该按照题意来，可以替换成&lt;=元素个数n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;arr.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="comment">//arr[i-1]&lt;=arr[i]时已经有序</span></span><br><span class="line">        <span class="keyword">if</span>(arr[i<span class="number">-1</span>]&gt;arr[i])&#123;</span><br><span class="line">            <span class="comment">//设置哨兵</span></span><br><span class="line">            arr[<span class="number">0</span>]=arr[i];</span><br><span class="line">            <span class="comment">//直接j=i-1会导致比较次数多一次</span></span><br><span class="line">            arr[i]=arr[i<span class="number">-1</span>];</span><br><span class="line">            <span class="type">int</span> j=i<span class="number">-2</span>;</span><br><span class="line">            <span class="comment">//只要前面的比自己大就将其后移</span></span><br><span class="line">            <span class="keyword">while</span>(arr[j]&gt;arr[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="comment">//边查找变移动</span></span><br><span class="line">                arr[j<span class="number">+1</span>]=arr[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//多移动了一位才退出循环所以是j+1</span></span><br><span class="line">            arr[j<span class="number">+1</span>]=arr[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>稳定排序，每次比较将能插入就马上插入。</p>
</li>
<li><p>时间复杂度：最好O(n) 最坏O($n^2$)</p>
<pre><code>  最好的情况是数组已经有序，只需要比较n-1次就完成了排序
  最坏的情况是数组逆序排列，每次插入元素都要找到哨兵才能停止。需要比较∑(2,n)i次也就是(n+2)(n-1)/2次，移动∑(2,n)i+1也就是(n+4)(n-1)/2次。
  引入二分也难以避免移动带来的开销。
</code></pre>
</li>
<li><p>空间复杂度： O(1)</p>
</li>
</ul>
</li>
</ul>
<h3 id="B-希尔排序"><a href="#B-希尔排序" class="headerlink" title="B. 希尔排序"></a>B. 希尔排序</h3><ul>
<li><p>细节</p>
<pre><code>  将数组分为若干个数组，并不断减少分组数，最后分组数为1时数组已经基本有序。希尔排序的分组序列是关键。
</code></pre>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellInesert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr,<span class="type">int</span> dk)</span></span>&#123;</span><br><span class="line">    <span class="comment">//arr从1号位置开始存储信息</span></span><br><span class="line">    <span class="comment">//0号位置用于暂存</span></span><br><span class="line">    <span class="comment">//dk是当前的分组个数</span></span><br><span class="line">    <span class="comment">//arr.size()这里应该按照题意来，可以替换成&lt;=元素个数n</span></span><br><span class="line">    <span class="comment">//这里只不过是把增量变为不确定的值</span></span><br><span class="line">    <span class="comment">//i=dk+1指向的是一个分组中的第二个元素，对各组间进行异步的插入排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=dk<span class="number">+1</span>;i&lt;arr.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;arr[i-dk])&#123;</span><br><span class="line">            arr[<span class="number">0</span>]=arr[i];</span><br><span class="line">            arr[i]=arr[i-dk];</span><br><span class="line">            <span class="type">int</span> j=i<span class="number">-2</span>*dk;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;arr[<span class="number">0</span>]&lt;arr[j])&#123;</span><br><span class="line">                arr[j+dk]=arr[j];</span><br><span class="line">                j-=dk;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+dk]=arr[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr,vector&lt;<span class="type">int</span>&gt;&amp;dlta)</span></span>&#123;</span><br><span class="line">    <span class="comment">//dlta是增量的递减序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;dk:dlta)&#123;</span><br><span class="line">        <span class="built_in">ShellInesert</span>(arr,dk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>封装</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ShellSort = [&amp;](vector&lt;<span class="type">int</span>&gt;&amp; arr)-&gt;<span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> ShellInesert = [&amp;](vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> dk)-&gt;<span class="type">void</span> &#123;</span><br><span class="line">        <span class="comment">//dk是当前的分组个数</span></span><br><span class="line">        <span class="comment">//i=dk指向的是一个分组中的第二个元素，对各组间进行异步的插入排序</span></span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = dk; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[i - dk]) &#123;</span><br><span class="line">                temp = arr[i];</span><br><span class="line">                arr[i] = arr[i - dk];</span><br><span class="line">                <span class="type">int</span> j = i - <span class="number">2</span> * dk;</span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j]) &#123;</span><br><span class="line">                    arr[j + dk] = arr[j];</span><br><span class="line">                    j -= dk;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j + dk] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//dlta是增量的递减序列，需要修改</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;dlta&#123; <span class="number">15</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; dk : dlta) &#123;</span><br><span class="line">        <span class="built_in">ShellInesert</span>(arr, dk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>不稳定排序，可能将相等的元素位置颠倒</p>
</li>
<li><p>时间复杂度主要取决于dlta的选取，研究表明当$dlta[k]&#x3D;2^{dn-k+1}-1$时时间复杂度可以为O($n^{3&#x2F;2}$)，也要注意dlta各元素要互质。</p>
</li>
<li><p>空间复杂度： O(1)</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2. 冒泡排序"></a>2. 冒泡排序</h2><ul>
<li><p>细节</p>
<pre><code>  每次将相邻元素相互比较，将特定元素往后移。
</code></pre>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=arr.<span class="built_in">size</span>();i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j<span class="number">-1</span>]&gt;arr[j])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[j],arr[j<span class="number">-1</span>]);</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>稳定排序</p>
</li>
<li><p>时间复杂度： 最好O(n) 最差O($n^2$)</p>
<pre><code>  最好时是序列已经有序，只需要比较n-1次。
  最坏时是序列逆序排列，需要比较∑(2,n)(i-1)也就是n(n-1)/2次。
</code></pre>
</li>
<li><p>空间复杂度： O(1)</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-快速排序"><a href="#3-快速排序" class="headerlink" title="3. 快速排序"></a>3. 快速排序</h2><p>快速排序趟排序至少能找到一个正确的位置（枢轴）。</p>
<p>快速排序的nlogn常数很小。</p>
<ul>
<li><p>细节</p>
<pre><code>快速排序主要是利用分治的思想，将数组分为一个个数组，对每个数组选定一个枢轴，将其中元素分在枢轴两端，然后将枢轴两端元素分别再分割为两个数组再如此操作。
</code></pre>
</li>
<li><p>代码实现</p>
<ul>
<li><p>固定枢轴</p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr,<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="comment">//是从1号位置开始存储信息</span></span><br><span class="line">    <span class="comment">//0号位置存储枢轴信息</span></span><br><span class="line">    <span class="comment">//固定low位置作为枢轴</span></span><br><span class="line">    arr[<span class="number">0</span>]=arr[low];</span><br><span class="line">    <span class="type">int</span> pivotkey=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="comment">//可以保证的是每次循环结束时low总是指向枢轴</span></span><br><span class="line">        <span class="comment">//从右端找到第一个小于枢轴的位置与枢轴位置交换。</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;arr[high]&gt;=pivotkey)high--;</span><br><span class="line">        <span class="comment">//枢轴位置不用赋值，不一定是最后位置</span></span><br><span class="line">        arr[low]=arr[high];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;arr[low]&lt;=pivotkey)low++;</span><br><span class="line">        arr[high]=arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low]=pivotkey;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Selected</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr,<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> pivotloc=<span class="built_in">Partition</span>(arr,low,high);</span><br><span class="line">        <span class="built_in">Selected</span>(arr,low,pivotloc<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">Selected</span>(arr,pivotloc<span class="number">+1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Selected</span>(arr,<span class="number">1</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不稳定排序。</p>
</li>
<li><p>时间复杂度： 最好O(nlogn) 最坏O($n^2$)</p>
<pre><code>  最好出现在数组基本无序。
  最坏出现在数组基本有序，这样枢轴每次都不能移动。
</code></pre>
</li>
<li><p>空间复杂度： 由于每个枢轴都要一次调用 最好O(logn) 最坏O(n)</p>
</li>
</ul>
</li>
<li><p>引入随机枢轴</p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//0号位置开始存储信息</span></span><br><span class="line">    <span class="type">int</span> pivot=nums[r];</span><br><span class="line">    <span class="comment">//i维护的是最后一个小于等于枢轴的位置 i+1就是枢轴的最后位置</span></span><br><span class="line">    <span class="type">int</span> i=l<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//r已经是当前枢轴的位置，不必比较了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=l; j&lt;=r<span class="number">-1</span>;j++) &#123;</span><br><span class="line">        <span class="comment">//当遍历时发现小于等于枢轴的元素将其与i+1交换位置</span></span><br><span class="line">        <span class="comment">//保证i+1填入枢轴是正确的</span></span><br><span class="line">        <span class="keyword">if</span> (nums[j]&lt;=pivot) &#123;</span><br><span class="line">            i=i<span class="number">+1</span>;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将枢轴放在正确位置</span></span><br><span class="line">    <span class="built_in">swap</span>(nums[i<span class="number">+1</span>],nums[r]);</span><br><span class="line">    <span class="keyword">return</span> i<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">randomized_partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//随机选择一个下标作为枢轴</span></span><br><span class="line">    <span class="type">int</span> i=<span class="built_in">rand</span>()%(r-l<span class="number">+1</span>)+l;</span><br><span class="line">    <span class="comment">//把选出来的枢轴放到最右边</span></span><br><span class="line">    <span class="built_in">swap</span>(nums[r],nums[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">partition</span>(nums, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">randomized_selected</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;r) &#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">randomized_partition</span>(arr, l, r);</span><br><span class="line">        <span class="built_in">randomized_selected</span>(arr, l, pos - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">randomized_selected</span>(arr, pos + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="built_in">randomized_selected</span>(arr,<span class="number">0</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>封装</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> Qsort = [&amp;](vector&lt;<span class="type">int</span>&gt;&amp; arr)-&gt;<span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> partition = [&amp;](vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">        <span class="type">int</span> pivot = nums[r];</span><br><span class="line">        <span class="comment">//i维护的是最后一个小于等于枢轴的位置 i+1就是枢轴的最后位置</span></span><br><span class="line">        <span class="type">int</span> i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//r已经是当前枢轴的位置，不必比较了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = l; j &lt;= r - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//当遍历时发现小于等于枢轴的元素将其与i+1交换位置</span></span><br><span class="line">            <span class="comment">//保证i+1填入枢轴是正确的</span></span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将枢轴放在正确位置</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[i + <span class="number">1</span>], nums[r]);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> randomized_partition = [&amp;](vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">        <span class="comment">//随机选择一个下标作为枢轴</span></span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">        <span class="comment">//把选出来的枢轴放到最右边</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[r], nums[i]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">partition</span>(nums, l, r);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="type">void</span>(vector&lt;<span class="type">int</span>&gt;&amp;, <span class="type">int</span>, <span class="type">int</span>)&gt; randomized_selected = [&amp;](vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> pos = <span class="built_in">randomized_partition</span>(arr, l, r);</span><br><span class="line">            <span class="built_in">randomized_selected</span>(arr, l, pos - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">randomized_selected</span>(arr, pos + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="built_in">randomized_selected</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<p>  基本与前面一致，但更多时候时间复杂度为O(nlogn)，空间复杂度为O(logn)。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-选择排序"><a href="#4-选择排序" class="headerlink" title="4. 选择排序"></a>4. 选择排序</h2><h3 id="A-简单选择排序"><a href="#A-简单选择排序" class="headerlink" title="A. 简单选择排序"></a>A. 简单选择排序</h3><ul>
<li><p>细节</p>
<pre><code>  从无序序列中找到最值加入有序序列。
</code></pre>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="built_in">min_element</span>(arr.<span class="built_in">begin</span>()+i,arr.<span class="built_in">end</span>())-arr.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">if</span>(i!=j)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>一般来说是不稳定的，也可以做成稳定。</p>
</li>
<li><p>时间复杂度： O($n^2$)</p>
<pre><code>  最多移动元素出现在每两个元素都要交换，每次交换需要一个temp，导致每次产生3次交换次数，共计3(n-1)次；最少出现在已经有序，需要移动0次。
  比较次数为∑(1,n)(n-i)也就是n(n-1)/2。
</code></pre>
</li>
<li><p>空间复杂度： O(1)</p>
</li>
</ul>
</li>
</ul>
<h3 id="B-堆排序"><a href="#B-堆排序" class="headerlink" title="B. 堆排序"></a>B. 堆排序</h3><ul>
<li><p>细节</p>
<pre><code>  对于所有子树元素都满足大于或小于根节点的树称为堆，堆顶可作为本次输出元素，维护下一个输出元素时可以利用之前取得的信息。
</code></pre>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr,<span class="type">int</span> cur,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="comment">//本次操作之前[cur:m]除去cur节点其余已经具备堆的特性</span></span><br><span class="line">    <span class="comment">//本次操作是将[cur:m]完全变为堆</span></span><br><span class="line">    <span class="comment">//这里的写法是针对元素由1号开始存储来编写，左子树2*i，右子树2*i+1</span></span><br><span class="line">    <span class="comment">//若从0号位置开始存储，左子树为2*i+1,右子树为2*i+2</span></span><br><span class="line">    <span class="comment">//cur维护的是新加入堆的元素位置</span></span><br><span class="line">    <span class="type">int</span> rootval=arr[cur];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*cur;i&lt;=m;i*=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//选择最大的一颗子树节点</span></span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">+1</span>&lt;=m&amp;&amp;arr[i]&lt;arr[i<span class="number">+1</span>])i++;</span><br><span class="line">        <span class="comment">//若大于(小于)当前根节点就将其上移,否则已经找到最终位置</span></span><br><span class="line">        <span class="keyword">if</span>(rootval&gt;=arr[i])<span class="keyword">break</span>;</span><br><span class="line">        arr[cur]=arr[i];</span><br><span class="line">        cur=i;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[cur]=rootval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=arr.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//n/2下标是最后一个含有叶子的子树，自底而上建立堆</span></span><br><span class="line">    <span class="comment">//自顶而下很难保证每一次都能在正确的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(arr,i,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//i==1的时候没必要再来一次了</span></span><br><span class="line">    <span class="comment">//每次把堆顶元素放到最后再将一个叶子放在堆顶再重建堆完成排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i],arr[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(arr,<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>封装</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> HeapSort = [&amp;](vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> k)-&gt;<span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [&amp;](<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)-&gt;<span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= b)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> HeapAdjust = [&amp;](vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> cur, <span class="type">int</span> m) &#123;</span><br><span class="line">        <span class="type">int</span> rootval = arr[cur];</span><br><span class="line">        <span class="comment">//注意i=2*i+1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * cur + <span class="number">1</span>; i &lt;= m; i = <span class="number">2</span> * i + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt;= m &amp;&amp; <span class="built_in">cmp</span>(arr[i], arr[i + <span class="number">1</span>]))i++;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">cmp</span>(rootval,arr[i]))<span class="keyword">break</span>;</span><br><span class="line">            arr[cur] = arr[i];</span><br><span class="line">            cur = i;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[cur] = rootval;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (n<span class="number">-2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(arr, i, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(arr, <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>不稳定排序。</p>
</li>
<li><p>时间复杂度： O(nlogn)</p>
</li>
<li><p>空间复杂度： O(1)</p>
</li>
</ul>
</li>
</ul>
<h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h2><ul>
<li><p>细节</p>
<pre><code>  将两个有序数组重新组合只需要耗费线性，利用分治的思想，将一个数组不断切分，找到切分为由一个元素组成的序列，再和其余序列合并，不断合并最终有序。
</code></pre>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;partOrdered,vector&lt;<span class="type">int</span>&gt;&amp;arr,<span class="type">int</span> f,<span class="type">int</span> m,<span class="type">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这个地方partOrdered一定要开新空间，没法避免</span></span><br><span class="line">    <span class="comment">//将partOrdered[f:m]和partOrdered[m+1:e]并入为有序的arr[f:e]</span></span><br><span class="line">    <span class="comment">//p维护的是加入arr中的位置，s维护的是第二部分需要并入的位置</span></span><br><span class="line">    <span class="comment">//p不用比较了，一定不会越界</span></span><br><span class="line">    <span class="type">int</span> p=f,s=m<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">while</span>(f&lt;=m&amp;&amp;s&lt;=e)&#123;</span><br><span class="line">        <span class="keyword">if</span>(partOrdered[f]&lt;=partOrdered[s])&#123;</span><br><span class="line">            arr[p++]=partOrdered[f++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> arr[p++]=partOrdered[s++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(f&lt;=m)&#123;</span><br><span class="line">        arr[p++]=partOrdered[f++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(s&lt;=m)&#123;</span><br><span class="line">        arr[p++]=partOrdered[s++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Msort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;pre,vector&lt;<span class="type">int</span>&gt;&amp;ordered,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这个地方pre可以不开空间，当ordered被修改时，pre的对应位置也一定不再使用了</span></span><br><span class="line">    <span class="comment">//将pre[l:r]归并排序后放入ordered</span></span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="comment">//递归退出条件</span></span><br><span class="line">        ordered[l]=pre[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//一分为二</span></span><br><span class="line">        <span class="type">int</span> mid=(r-l)/<span class="number">2</span>+l;</span><br><span class="line">        <span class="comment">//将左半的结果放进ordered</span></span><br><span class="line">        <span class="built_in">Msort</span>(pre,ordered,l,mid);</span><br><span class="line">        <span class="comment">//将右半的结果放进ordered</span></span><br><span class="line">        <span class="built_in">Msort</span>(pre,ordered,mid<span class="number">+1</span>,r);</span><br><span class="line">        <span class="comment">//合并两个结果</span></span><br><span class="line">        <span class="built_in">Merge</span>(ordered,ordered,l,mid,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Msort</span>(arr,arr,<span class="number">0</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>稳定排序。</p>
</li>
<li><p>时间复杂度： O(nlogn)</p>
</li>
<li><p>空间复杂度： O(nlogn)</p>
<pre><code>  申请了logn次（由于二分）n大小的辅助空间。
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="6-基数排序"><a href="#6-基数排序" class="headerlink" title="6. 基数排序"></a>6. 基数排序</h2><ul>
<li><p>细节</p>
<pre><code>  利用了LSD的原理，将每个关键字位的比较叠加，取消了对关键字与关键字之间的比较，先分配再收集完成排序。LSD的排序要求每次排序都是稳定的。利用f和e数组分别维护关于同关键字位的序列中头与尾。
</code></pre>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_D 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_R 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Distribute</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;arr,<span class="type">int</span> time,vector&lt;<span class="type">int</span>&gt;&amp;f,vector&lt;<span class="type">int</span>&gt;&amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//arr这里是一个静态链表，其中零号位置作为头指针</span></span><br><span class="line">    <span class="comment">//这里没有初始化e，因为e在使用到的时候一定会刷新</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NUM_R;i++)&#123;</span><br><span class="line">        f[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//p==0时指向头指针时退出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=arr[<span class="number">0</span>][<span class="number">1</span>];p;p=arr[p][<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="type">int</span> j=(arr[p][<span class="number">0</span>]/time)%NUM_R;</span><br><span class="line">        <span class="keyword">if</span>(!f[j])f[j]=p;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            arr[e[j]][<span class="number">1</span>]=p;</span><br><span class="line">        &#125;</span><br><span class="line">        e[j]=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Collect</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;arr,vector&lt;<span class="type">int</span>&gt;&amp;f,vector&lt;<span class="type">int</span>&gt;&amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//ptr维护的是当前的收集到的位数</span></span><br><span class="line">    <span class="comment">//pre维护的是上一个非空子表的末尾元素</span></span><br><span class="line">    <span class="comment">//pre初始化为0最省事</span></span><br><span class="line">    <span class="type">int</span> ptr=<span class="number">0</span>,pre=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr&lt;<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(ptr&lt;<span class="number">10</span>&amp;&amp;!f[ptr])ptr++;</span><br><span class="line">        <span class="keyword">if</span>(ptr&lt;<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="comment">//将两子表头尾相接</span></span><br><span class="line">            arr[pre][<span class="number">1</span>]=f[ptr];</span><br><span class="line">            pre=e[ptr];</span><br><span class="line">        &#125;</span><br><span class="line">        ptr++;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[pre][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//新建静态链表</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">ptr_arr</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ptr_arr[i<span class="number">+1</span>][<span class="number">0</span>]=arr[i];</span><br><span class="line">        ptr_arr[i][<span class="number">1</span>]=i<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">f</span>(NUM_R),<span class="built_in">e</span>(NUM_R);</span><br><span class="line">    <span class="type">int</span> time=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NUM_D;i++)&#123;</span><br><span class="line">        <span class="built_in">Distribute</span>(ptr_arr,time,f,e);</span><br><span class="line">        <span class="built_in">Collect</span>(ptr_arr,f,e);</span><br><span class="line">        time*=NUM_R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p=ptr_arr[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        arr[i]=ptr_arr[p][<span class="number">0</span>];</span><br><span class="line">        p=ptr_arr[p][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>稳定排序。但注意很难实现对double的排序。</p>
</li>
<li><p>时间复杂度： O(d(n+r))</p>
<pre><code>需要执行d次收集和分配，其中分配需要n，分配需要r（每一次需要看完r个f）。
</code></pre>
</li>
<li><p>空间复杂度： 一般为O(r)，但本处为O(n+r)。</p>
<pre><code>  新建两个大小为r的数组f、e；若本来就是静态链表n也可以避免。
</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="高级数据结构"><a href="#高级数据结构" class="headerlink" title="高级数据结构"></a><strong>高级数据结构</strong></h1><h2 id="1-并查集"><a href="#1-并查集" class="headerlink" title="1. 并查集"></a>1. 并查集</h2><ul>
<li><p>细节</p>
<p>  面对配对、分组问题，快速分组整合。</p>
<pre><code>  vector&lt;int&gt; parent;     记录父节点
  vector&lt;int&gt; size;       记录当前子树的大小(优化树)
  int n;                  顶点数
  int setCount;           集合数
    
  UnionFind(int)          初始化，将每个元素的父节点定义为自己，树大小定义为1
  findset(int)            返回对应顶点编号的父节点
  unite(int,int)          将两个集合合并(两个集合的父节点合并)
  findAndUnite(int,int)   将两个集合合并如已经在同一个集合内返回false，否则返回true。
</code></pre>
</li>
<li><p>封装</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; size;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> setCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size[x] &lt; size[y]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        parent[y] = x;</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        --setCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> _n): <span class="built_in">n</span>(_n), <span class="built_in">setCount</span>(_n), <span class="built_in">parent</span>(_n), <span class="built_in">size</span>(_n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">iota</span>(parent.<span class="built_in">begin</span>(), parent.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findset</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent[x] == x ? x : parent[x] = <span class="built_in">findset</span>(parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findAndUnite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> parentX = <span class="built_in">findset</span>(x);</span><br><span class="line">        <span class="type">int</span> parentY = <span class="built_in">findset</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (parentX != parentY) &#123;</span><br><span class="line">            <span class="built_in">unite</span>(parentX, parentY);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connected</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findset</span>(x)==<span class="built_in">findset</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：单次合并O(logn) </p>
</li>
<li><p>空间复杂度：O(n)</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-线段树"><a href="#2-线段树" class="headerlink" title="2. 线段树"></a>2. 线段树</h2><p>区间查询</p>
<ul>
<li><p>细节</p>
<pre><code>  类二叉搜索树的特性，但每个节点存放一个区间(lo,hi)，计算得mid=(lo+hi)&gt;&gt;1，其左子树存放区间(lo,mid)，其右子树存放区间(mid+1,hi)。而每个区间可以分别计数并由数的性质将其父节点也同时维护。
  
  当[left,right]数据比较离散时，最好映射到(0,x)这个区间，以节省空间，要保证大的数其映射的值也对应大。（排序再分配）
  
  SegNode* build(int left, int right)             初始化一个区间为[left,right]的线段树。
  void insert(SegNode* root, int val)             向树插入val，维护对应区间的值
  int count(SegNode* root, int left, int right)   查找[left,right]区间的总和值
</code></pre>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="维护前缀和"><a href="#维护前缀和" class="headerlink" title="维护前缀和"></a>维护前缀和</h4><ul>
<li><p>单点更新（插入新值）区间查询。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegNode</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> lo, hi;</span><br><span class="line">    <span class="type">int</span> add;</span><br><span class="line">    SegNode* lchild, *rchild;</span><br><span class="line">    <span class="built_in">SegNode</span>(<span class="type">long</span> <span class="type">long</span> left, <span class="type">long</span> <span class="type">long</span> right): <span class="built_in">lo</span>(left), <span class="built_in">hi</span>(right), <span class="built_in">add</span>(<span class="number">0</span>), <span class="built_in">lchild</span>(<span class="literal">nullptr</span>), <span class="built_in">rchild</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SegNode* SegSuper;</span><br><span class="line"></span><br><span class="line"><span class="function">SegNode* <span class="title">build</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    SegNode* node = <span class="keyword">new</span> <span class="built_in">SegNode</span>(left, right);</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    node-&gt;lchild = <span class="built_in">build</span>(left, mid);</span><br><span class="line">    node-&gt;rchild = <span class="built_in">build</span>(mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(SegNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    root-&gt;add++;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lo == root-&gt;hi) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (root-&gt;lo + root-&gt;hi) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (val &lt;= mid) &#123;</span><br><span class="line">        <span class="built_in">insert</span>(root-&gt;lchild, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">insert</span>(root-&gt;rchild, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(SegNode* root, <span class="type">int</span> left, <span class="type">int</span> right)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; root-&gt;hi || right &lt; root-&gt;lo) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &lt;= root-&gt;lo &amp;&amp; root-&gt;hi &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">count</span>(root-&gt;lchild, left, right) + <span class="built_in">count</span>(root-&gt;rchild, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单点更新 区间查询 窗口内第k大元素</p>
<p>  数据范围确定（线段树大小）、点定为1</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Segment</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> d,<span class="type">int</span> sl,<span class="type">int</span> sr,<span class="type">int</span> ptr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sl==sr)&#123;</span><br><span class="line">            Tree[ptr]+=d;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=(sl+sr)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=mid)&#123;</span><br><span class="line">            <span class="built_in">update</span>(x,d,sl,mid,ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">update</span>(x,d,mid<span class="number">+1</span>,sr,(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Tree[ptr]=Tree[ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+Tree[(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">quary</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> sl,<span class="type">int</span> sr,<span class="type">int</span> ptr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=sl&amp;&amp;sr&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">return</span> Tree[ptr];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=(sl+sr)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)&#123;</span><br><span class="line">            ans+=<span class="built_in">quary</span>(l,r,sl,mid,ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid<span class="number">+1</span>&lt;=r)&#123;</span><br><span class="line">            ans+=<span class="built_in">quary</span>(l,r,mid<span class="number">+1</span>,sr,(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find_by_rank</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> sl,<span class="type">int</span> sr,<span class="type">int</span> ptr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sl==sr)&#123;</span><br><span class="line">            <span class="keyword">return</span> sl; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=(sl+sr)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(Tree[ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]&gt;=k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find_by_rank</span>(k,sl,mid,ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find_by_rank</span>(k-Tree[ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],mid<span class="number">+1</span>,sr,(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;Tree;</span><br><span class="line">    <span class="built_in">Segment</span>(<span class="type">int</span> n):<span class="built_in">n</span>(n)&#123;</span><br><span class="line">        Tree.<span class="built_in">resize</span>(n&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(x,d,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">quary</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quary</span>(l,r,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find_by_rank</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find_by_rank</span>(k,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>区间查询 GCD</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Segment</span>&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> sl,<span class="type">int</span> sr,<span class="type">int</span> ptr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sl==sr)&#123;</span><br><span class="line">        Tree[ptr]=nums[sl];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(sl+sr)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(sl,mid,ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(mid<span class="number">+1</span>,sr,(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>);</span><br><span class="line">    Tree[ptr]=<span class="built_in">gcd</span>(Tree[ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],Tree[(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quary</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> sl,<span class="type">int</span> sr,<span class="type">int</span> ptr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=sl&amp;&amp;sr&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> Tree[ptr];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(sl+sr)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)&#123;</span><br><span class="line">        ans=<span class="built_in">quary</span>(l,r,sl,mid,ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mid<span class="number">+1</span>&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans==<span class="number">-1</span>)ans=<span class="built_in">quary</span>(l,r,mid<span class="number">+1</span>,sr,(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans=<span class="built_in">gcd</span>(ans,<span class="built_in">quary</span>(l,r,mid<span class="number">+1</span>,sr,(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;Tree,nums;</span><br><span class="line">    <span class="built_in">Segment</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums):<span class="built_in">nums</span>(nums)&#123;</span><br><span class="line">        n=nums.<span class="built_in">size</span>();</span><br><span class="line">        Tree.<span class="built_in">resize</span>(n&lt;&lt;<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">quary</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quary</span>(l,r,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>区域维护 区域查询</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Segment</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            Tree[ptr] = nums[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(nums, l, mid, ptr &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">build</span>(nums, mid + <span class="number">1</span>, r, (ptr &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">push_up</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> ptr,T len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Add[ptr] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> left = ptr &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, right = (ptr &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">            Add[left] += Add[ptr];</span><br><span class="line">            Add[right] += Add[ptr];</span><br><span class="line">            Tree[left] += Add[ptr]*(len - len/<span class="number">2</span>);</span><br><span class="line">            Tree[right] += Add[ptr]*(len/<span class="number">2</span>);</span><br><span class="line">            Add[ptr] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> ptr)</span> </span>&#123;</span><br><span class="line">        Tree[ptr] = Tree[ptr &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] + Tree[(ptr &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> sl, <span class="type">int</span> sr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> val, <span class="type">int</span> ptr)</span> </span>&#123;</span><br><span class="line">        T len = r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(sl &lt;= l &amp;&amp; r &lt;= sr) &#123;</span><br><span class="line">            Add[ptr] += val;</span><br><span class="line">            Tree[ptr] += len*val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(ptr, len);</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(sl &lt;= mid) &#123;</span><br><span class="line">            <span class="built_in">update</span>(sl, sr, l, mid, val, ptr &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= sr) &#123;</span><br><span class="line">            <span class="built_in">update</span>(sl, sr, mid + <span class="number">1</span>, r, val, (ptr &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_up</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">query</span><span class="params">(<span class="type">int</span> sl, <span class="type">int</span> sr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sl &lt;= l &amp;&amp; r &lt;= sr)&#123;</span><br><span class="line">            <span class="keyword">return</span> Tree[ptr];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(ptr, r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        T ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(sl &lt;= mid) &#123;</span><br><span class="line">            ans += <span class="built_in">query</span>(sl, sr, l, mid, ptr &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= sr) &#123;</span><br><span class="line">            ans += <span class="built_in">query</span>(sl, sr, mid + <span class="number">1</span>, r, (ptr &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;T&gt;Tree;</span><br><span class="line">    vector&lt;T&gt;Add;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Segment</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = nums.<span class="built_in">size</span>();</span><br><span class="line">        Tree.<span class="built_in">resize</span>(<span class="number">4</span> * n);</span><br><span class="line">        Add.<span class="built_in">resize</span>(<span class="number">4</span> * n);</span><br><span class="line">        <span class="built_in">build</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(l, r, <span class="number">0</span>, n<span class="number">-1</span>, val, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(l, r, <span class="number">0</span>, n<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>区间反转 区间查询 （01线段树）</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Segment</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(vector&lt;T&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            Tree[ptr] = nums[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(nums, l, mid, ptr &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">build</span>(nums, mid + <span class="number">1</span>, r, (ptr &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">push_up</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> ptr,<span class="type">long</span> <span class="type">long</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Add[ptr]) &#123;</span><br><span class="line">            <span class="type">int</span> left = ptr &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, right = (ptr &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">            Add[left] = !Add[left];</span><br><span class="line">            Add[right] = !Add[right];</span><br><span class="line">            Tree[left] = len-len/<span class="number">2</span>-Tree[left];</span><br><span class="line">            Tree[right] = len/<span class="number">2</span>-Tree[right];</span><br><span class="line">            Add[ptr] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> ptr)</span> </span>&#123;</span><br><span class="line">        Tree[ptr] = Tree[ptr &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] + Tree[(ptr &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(<span class="type">int</span> sl, <span class="type">int</span> sr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ptr)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(sl &lt;= l &amp;&amp; r &lt;= sr) &#123;</span><br><span class="line">            Add[ptr] = !Add[ptr];</span><br><span class="line">            Tree[ptr] = len - Tree[ptr];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">push_down</span>(ptr, len);</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(sl &lt;= mid) &#123;</span><br><span class="line">                <span class="built_in">flip</span>(sl, sr, l, mid, ptr &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= sr) &#123;</span><br><span class="line">                <span class="built_in">flip</span>(sl, sr, mid + <span class="number">1</span>, r, (ptr &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">push_up</span>(ptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">int</span> sl, <span class="type">int</span> sr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sl &lt;= l &amp;&amp; r &lt;= sr)&#123;</span><br><span class="line">            <span class="keyword">return</span> Tree[ptr];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(ptr, r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(sl &lt;= mid) &#123;</span><br><span class="line">            ans += <span class="built_in">query</span>(sl, sr, l, mid, ptr &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= sr) &#123;</span><br><span class="line">            ans += <span class="built_in">query</span>(sl, sr, mid + <span class="number">1</span>, r, (ptr &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;Tree;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt;Add;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Segment</span>(vector&lt;T&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = nums.<span class="built_in">size</span>();</span><br><span class="line">        Tree.<span class="built_in">resize</span>(<span class="number">4</span> * n);</span><br><span class="line">        Add.<span class="built_in">resize</span>(<span class="number">4</span> * n);</span><br><span class="line">        <span class="built_in">build</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">flip</span>(l, r, <span class="number">0</span>, n<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(l, r, <span class="number">0</span>, n<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>区域维护 维护单位</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Segment</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;ll&gt;Tree,Add;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> ptr)</span></span>&#123;<span class="keyword">return</span> (ptr&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> ptr)</span></span>&#123;<span class="keyword">return</span> (ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> ptr)</span></span>&#123;</span><br><span class="line">        Tree[ptr]=Tree[<span class="built_in">left</span>(ptr)]|Tree[<span class="built_in">right</span>(ptr)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> ptr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Add[ptr]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            Tree[<span class="built_in">left</span>(ptr)]=Add[ptr];</span><br><span class="line">            Add[<span class="built_in">left</span>(ptr)]=Add[ptr];</span><br><span class="line">            Tree[<span class="built_in">right</span>(ptr)]=Add[ptr];</span><br><span class="line">            Add[<span class="built_in">right</span>(ptr)]=Add[ptr];</span><br><span class="line">            Add[ptr]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Segment</span>(<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n=n;</span><br><span class="line">        Tree.<span class="built_in">resize</span>(<span class="number">4</span>*n);</span><br><span class="line">        Add.<span class="built_in">resize</span>(<span class="number">4</span>*n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bulid</span><span class="params">(vector&lt;ll&gt;&amp;a,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ptr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            Tree[ptr]=a[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">bulid</span>(a,l,m,<span class="built_in">left</span>(ptr));</span><br><span class="line">        <span class="built_in">bulid</span>(a,m<span class="number">+1</span>,r,<span class="built_in">right</span>(ptr));</span><br><span class="line">        <span class="built_in">push_up</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> tl,<span class="type">int</span> tr,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ptr,ll val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tl&lt;=l&amp;&amp;r&lt;=tr)&#123;</span><br><span class="line">            Add[ptr]=val;</span><br><span class="line">            Tree[ptr]=val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(ptr);</span><br><span class="line">        <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tl&lt;=m)&#123;</span><br><span class="line">            <span class="built_in">update</span>(tl,tr,l,m,<span class="built_in">left</span>(ptr),val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m&lt;tr)&#123;</span><br><span class="line">            <span class="built_in">update</span>(tl,tr,m<span class="number">+1</span>,r,<span class="built_in">right</span>(ptr),val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_up</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> tl,<span class="type">int</span> tr,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ptr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tl&lt;=l&amp;&amp;r&lt;=tr)&#123;</span><br><span class="line">            <span class="keyword">return</span> Tree[ptr];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(ptr);</span><br><span class="line">        <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tr&lt;=m)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(tl,tr,l,m,<span class="built_in">left</span>(ptr));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tl&gt;m)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(tl,tr,m<span class="number">+1</span>,r,<span class="built_in">right</span>(ptr));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tl,tr,l,m,<span class="built_in">left</span>(ptr))|<span class="built_in">query</span>(tl,tr,m<span class="number">+1</span>,r,<span class="built_in">right</span>(ptr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="维护区间最大值"><a href="#维护区间最大值" class="headerlink" title="维护区间最大值"></a>维护区间最大值</h4><ul>
<li><p>单点更新（修改原有值），区间查询。</p>
<ul>
<li><p>数组实现</p>
<p>  C++ new操作较慢，数组会相对快</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Segment</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">q</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">            <span class="keyword">return</span> Tree[ptr];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; r || y &lt; l) &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">q</span>(x, y, l, mid, ptr &lt;&lt; <span class="number">1</span> | <span class="number">1</span>), <span class="built_in">q</span>(x, y, mid + <span class="number">1</span>, r, (ptr &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            Tree[ptr] = nums[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(nums, l, mid, ptr &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">build</span>(nums, mid + <span class="number">1</span>, r, (ptr &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>);</span><br><span class="line">        Tree[ptr] = <span class="built_in">max</span>(Tree[ptr &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], Tree[(ptr &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _update(<span class="type">int</span> place, <span class="type">int</span> val, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ptr) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            Tree[ptr] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (place &lt;= mid) &#123;</span><br><span class="line">            _update(place, val, l, mid, ptr &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            _update(place, val, mid + <span class="number">1</span>, r, (ptr &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Tree[ptr] = <span class="built_in">max</span>(Tree[ptr &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], Tree[(ptr &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;Tree;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Segment</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = nums.<span class="built_in">size</span>();</span><br><span class="line">        Tree.<span class="built_in">resize</span>(<span class="number">4</span> * n);</span><br><span class="line">        <span class="built_in">build</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> place, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        _update(place, val, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">q</span>(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指针实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegNode</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> lo, hi;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    SegNode* lchild, *rchild;</span><br><span class="line">    <span class="built_in">SegNode</span>(<span class="type">long</span> <span class="type">long</span> left, <span class="type">long</span> <span class="type">long</span> right): <span class="built_in">lo</span>(left), <span class="built_in">hi</span>(right), <span class="built_in">val</span>(INT_MIN), <span class="built_in">lchild</span>(<span class="literal">nullptr</span>), <span class="built_in">rchild</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SegNode* SegSuper;</span><br><span class="line"></span><br><span class="line"><span class="function">SegNode* <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr,<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    SegNode* node = <span class="keyword">new</span> <span class="built_in">SegNode</span>(left, right);</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        node-&gt;val = arr[left];</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    node-&gt;lchild = <span class="built_in">build</span>(arr, left, mid);</span><br><span class="line">    node-&gt;rchild = <span class="built_in">build</span>(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">    node-&gt;val = <span class="built_in">max</span>(node-&gt;lchild-&gt;val,node-&gt;rchild-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(SegNode* root, <span class="type">int</span> place, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lo==root-&gt;hi)&#123;</span><br><span class="line">        root-&gt;val=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (root-&gt;lo + root-&gt;hi) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (place &lt;= mid) &#123;</span><br><span class="line">        <span class="built_in">update</span>(root-&gt;lchild, place, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">update</span>(root-&gt;rchild, place, val);</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;val=<span class="built_in">max</span>(root-&gt;lchild-&gt;val,root-&gt;rchild-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(SegNode* root, <span class="type">int</span> left, <span class="type">int</span> right)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; root-&gt;hi || right &lt; root-&gt;lo) &#123;</span><br><span class="line">        <span class="keyword">return</span> INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &lt;= root-&gt;lo &amp;&amp; root-&gt;hi &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">query</span>(root-&gt;lchild, left, right), <span class="built_in">query</span>(root-&gt;rchild, left, right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：预处理O(nlogn) 单次查找O(logn) 单次插入O(logn)</p>
</li>
<li><p>空间复杂度：O(n)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>区间更新（修改原有值）区间查询</p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Segment</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Add[ptr]!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> left=ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,right=(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>;</span><br><span class="line">            Add[left]=Add[ptr];</span><br><span class="line">            Add[right]=Add[ptr];</span><br><span class="line">            Mx[left]=Add[ptr];</span><br><span class="line">            Mx[right]=Add[ptr];</span><br><span class="line">            Add[ptr]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> ptr)</span> </span>&#123;</span><br><span class="line">        Mx[ptr]=<span class="built_in">max</span>(Mx[ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],Mx[(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> sl,<span class="type">int</span> sr,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val,<span class="type">int</span> ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sl&lt;=l&amp;&amp;r&lt;=sr) &#123;</span><br><span class="line">            Add[ptr]=val;</span><br><span class="line">            Mx[ptr]=val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(ptr);</span><br><span class="line">        <span class="type">int</span> mid =(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(sl &lt;= mid) &#123;</span><br><span class="line">            <span class="built_in">update</span>(sl,sr,l,mid,val,ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid<span class="number">+1</span>&lt;=sr) &#123;</span><br><span class="line">            <span class="built_in">update</span>(sl,sr,mid<span class="number">+1</span>,r,val,(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_up</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">int</span> sl,<span class="type">int</span> sr,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sl&lt;=l&amp;&amp;r&lt;=sr)&#123;</span><br><span class="line">            <span class="keyword">return</span> Mx[ptr];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(ptr);</span><br><span class="line">        <span class="type">int</span> mid =(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans=LLONG_MIN;</span><br><span class="line">        <span class="keyword">if</span>(sl&lt;=mid) &#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(sl,sr,l,mid,ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid<span class="number">+1</span>&lt;=sr) &#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(sl,sr,mid<span class="number">+1</span>,r,(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;Add;</span><br><span class="line">    vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;Mx;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Segment</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        Add.<span class="built_in">resize</span>(n&lt;&lt;<span class="number">2</span>);</span><br><span class="line">        Mx.<span class="built_in">resize</span>(n&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(l, r, <span class="number">0</span>, n<span class="number">-1</span>, val, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(l, r, <span class="number">0</span>, n<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li><p>由单个字符重复的最长子字符串</p>
<p>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-of-one-repeating-character/">https://leetcode.cn/problems/longest-substring-of-one-repeating-character/</a></p>
<ul>
<li><p>细节</p>
<p>  利用三颗线段树，分别维护前缀后缀数目、最大值来完成合并。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;pre,suf,maxp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> ptr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        pre[ptr]=suf[ptr]=maxp[ptr]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>((ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">push</span>(ptr,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> ptr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    pre[ptr]=pre[ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">    suf[ptr]=suf[(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>];</span><br><span class="line">    maxp[ptr]=<span class="built_in">max</span>(maxp[ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],maxp[(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>]);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[mid]==s[mid<span class="number">+1</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(suf[ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]==mid-l<span class="number">+1</span>)&#123;</span><br><span class="line">            pre[ptr]+=pre[(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>];</span><br><span class="line">            maxp[ptr]=<span class="built_in">max</span>(pre[ptr],maxp[ptr]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre[(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>]==r-mid)&#123;</span><br><span class="line">            suf[ptr]+=suf[ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">            maxp[ptr]=<span class="built_in">max</span>(suf[ptr],maxp[ptr]);</span><br><span class="line">        &#125;</span><br><span class="line">        maxp[ptr]=<span class="built_in">max</span>(maxp[ptr],suf[ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+pre[(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> ptr,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> idx,<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        s[l]=ch;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(idx&lt;=mid)&#123;</span><br><span class="line">        <span class="built_in">update</span>(ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,mid,idx,ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">update</span>((ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>,mid<span class="number">+1</span>,r,idx,ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push</span>(ptr,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">longestRepeating</span><span class="params">(string s, string queryCharacters, vector&lt;<span class="type">int</span>&gt;&amp; queryIndices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;s=s;</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">size</span>(),m=queryIndices.<span class="built_in">size</span>();</span><br><span class="line">    pre.<span class="built_in">resize</span>(n&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    suf.<span class="built_in">resize</span>(n&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    maxp.<span class="built_in">resize</span>(n&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">res</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>,queryIndices[i],queryCharacters[i]);</span><br><span class="line">        res[i]=maxp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>子数组不同元素数目的平方和 II</p>
<p>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarrays-distinct-element-sum-of-squares-ii/description/">https://leetcode.cn/problems/subarrays-distinct-element-sum-of-squares-ii/description/</a></p>
<ul>
<li><p>细节</p>
<p>  懒更新、<code>sum1</code>维护和，<code>sum2</code>维护平方和</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cnt[i,r]=cnt[j,r-1]+1 when j&gt;pre[nums[i]]</span></span><br><span class="line"><span class="comment">// cnt[i,r]=cnt[j,r-1]   when j&lt;=pre[nums[i]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (c+1)^2=c^2+2*c+1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>,mod=<span class="number">1e9</span><span class="number">+7</span>,n=nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">sum1</span>(n&lt;&lt;<span class="number">2</span>),<span class="built_in">sum2</span>(n&lt;&lt;<span class="number">2</span>),<span class="built_in">add</span>(n&lt;&lt;<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> put=[&amp;](<span class="type">int</span> ptr,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val)&#123;</span><br><span class="line">    <span class="type">int</span> len=r-l<span class="number">+1</span>;</span><br><span class="line">    sum2[ptr]=(sum2[ptr]<span class="number">+2ll</span>*val*sum1[ptr]<span class="number">+1ll</span>*val*val*len)%mod;</span><br><span class="line">    sum1[ptr]=(sum1[ptr]<span class="number">+1ll</span>*len*val)%mod;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> down=[&amp;](<span class="type">int</span> ptr,<span class="type">int</span> l,<span class="type">int</span> r)&#123;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    add[ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=add[ptr];</span><br><span class="line">    <span class="built_in">put</span>(ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,mid,add[ptr]);</span><br><span class="line">    add[(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>]+=add[ptr];</span><br><span class="line">    <span class="built_in">put</span>((ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>,mid<span class="number">+1</span>,r,add[ptr]);</span><br><span class="line">    add[ptr]=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> up=[&amp;](<span class="type">int</span> ptr,<span class="type">int</span> l,<span class="type">int</span> r)&#123;</span><br><span class="line">    sum1[ptr]=(sum1[ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+sum1[(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>])%mod;</span><br><span class="line">    sum2[ptr]=(sum2[ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+sum2[(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>])%mod;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)&gt;update=[&amp;](<span class="type">int</span> sl,<span class="type">int</span> sr,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val,<span class="type">int</span> ptr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(sl&lt;=l&amp;&amp;r&lt;=sr)&#123;</span><br><span class="line">        <span class="built_in">put</span>(ptr,l,r,val);</span><br><span class="line">        add[ptr]+=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(add[ptr])<span class="built_in">down</span>(ptr,l,r);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sl&lt;=mid)<span class="built_in">update</span>(sl,sr,l,mid,val,ptr&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(sr&gt;mid)<span class="built_in">update</span>(sl,sr,mid<span class="number">+1</span>,r,val,(ptr&lt;&lt;<span class="number">1</span>)<span class="number">+2</span>);</span><br><span class="line">    <span class="built_in">up</span>(ptr,l,r);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sum1=sum1+len*1 sum2=sum2+2*sum1+1</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;pre;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> pre_idx=pre.<span class="built_in">count</span>(nums[i])?pre[nums[i]]<span class="number">+1</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">update</span>(pre_idx,i,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    pre[nums[i]]=i;</span><br><span class="line">    res=(res+sum2[<span class="number">0</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="3-树状数组"><a href="#3-树状数组" class="headerlink" title="3. 树状数组"></a>3. 树状数组</h2><h3 id="A-单点维护-区间查询"><a href="#A-单点维护-区间查询" class="headerlink" title="A. 单点维护 区间查询"></a>A. 单点维护 区间查询</h3><ul>
<li><p>细节</p>
<p>  维护的是数组的前缀和。</p>
<p>  对于一个数x，他的父节点是x+lower(x)。</p>
<p>  每次单点更新一个值的时候将其所有的父节点同时更新。</p>
<pre><code>  int lowbit(int x)           		返回只保留二进制数x的最后一个1的二进制数。
  void update(int x, int d)   		单点更新x的位置增加d
  int query(int x)            		区间查询[1,x]
</code></pre>
<p>  tree下标0弃置，A下标+1。<br>  维护区间应该映射到[1,x+1]，x代表的是元素的个数。<br>  在做离散化的时候可以将其映射到[1,x+1]这样就可以不用在乎查询&#x2F;插入的时候下标+1。</p>
<pre><code>  A[1]    tree[1]=A[1];
  
  A[2]        tree[2]=A[1]+A[2];
  
  A[3]    tree[3]=A[3];
  
  A[4]            tree[4]=A[1]+A[2]+A[3]+A[4];
  
  A[5]    tree[5]=A[5];
  
  A[6]        tree[6]=A[5]+A[6];
  
  A[7]    tree[7]=A[7];
  
  A[8]                tree[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];
  
  单点更新x=1 -&gt; 维护1 2 4 8
  
  单点更新x=2 -&gt; 维护3 4 8
  
  区间查询x=3 -&gt; 查询3 2 -&gt; A[1]+A[2]+A[3]
</code></pre>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BIT</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tree;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BIT</span>(<span class="type">int</span> _n): <span class="built_in">n</span>(_n), <span class="built_in">tree</span>(_n + <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">            tree[x] += d;</span><br><span class="line">            x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            ans += tree[x];</span><br><span class="line">            x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(hi) - <span class="built_in">query</span>(lo - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：预处理O(nlogn) 单次查找O(logn) 单次插入O(logn)</p>
</li>
<li><p>空间复杂度：O(n)</p>
</li>
</ul>
</li>
</ul>
<h3 id="B-区间维护（单点维护）-区间查询"><a href="#B-区间维护（单点维护）-区间查询" class="headerlink" title="B. 区间维护（单点维护） 区间查询"></a>B. 区间维护（单点维护） 区间查询</h3><ul>
<li><p>细节</p>
<p>  利用前缀和和差分的概念。</p>
<p>  先引入$A_{i} &#x3D; \sum_{1}^{i} d_{x}$。</p>
<p>  那$A_{i}$的前缀和$\sum_{1}^{r} A_{i}$就等效于$\sum_{1}^{r}\sum_{1}^{i} d_{x}$。</p>
<p>  $\sum_{1}^{r}\sum_{1}^{i} d_{x}<br>  \&#x3D;d_{1}+(d_{1}+d_{2})+…+(d_{1}+d_{r})<br>  \&#x3D;rd_{1}+(r-1)d_{2}+…+d_{r}<br>  \&#x3D;\sum_{1}^{r} (r-x+1)d_{x}<br>  \&#x3D;r\sum_{1}^{r}{d_{x}}-\sum_{1}^{r}(x-1)d_{x}$</p>
<p>  所以选择维护两个BIT（$d_{x}$、$(x-1)d_{x}$）进而维护数组A的前缀和。</p>
<p>  单点维护可以由区间维护退变。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BIT</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; diff, diff_i;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">void</span> _update(<span class="type">int</span> x, <span class="type">int</span> d) &#123;</span><br><span class="line">        <span class="type">int</span> pos = x;</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">            diff[x] += d;</span><br><span class="line">            diff_i[x] += (pos - <span class="number">1</span>) * d;</span><br><span class="line">            x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BIT</span>(<span class="type">int</span> _n) : <span class="built_in">n</span>(_n), <span class="built_in">diff</span>(_n + <span class="number">1</span>), <span class="built_in">diff_i</span>(_n + <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(x, x, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> lo, <span class="type">int</span> hi, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        _update(lo, d);</span><br><span class="line">        _update(hi + <span class="number">1</span>, -d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, pos = x;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            res += (pos * diff[x] - diff_i[x]);</span><br><span class="line">            x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(hi) - <span class="built_in">query</span>(lo - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-字典树"><a href="#4-字典树" class="headerlink" title="4. 字典树"></a>4. 字典树</h2><ul>
<li><p>基础版</p>
<ul>
<li><p>基本结构</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">treeNode</span>&#123;</span><br><span class="line">    treeNode* next[<span class="number">26</span>]&#123;&#125;;</span><br><span class="line">    <span class="type">bool</span> isEnd=<span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本维护方式</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">super=<span class="keyword">new</span> <span class="built_in">treeNode</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;word:words)&#123;</span><br><span class="line">    treeNode *ptr=super;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:word)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ptr-&gt;next[c-<span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">            ptr-&gt;next[c-<span class="string">&#x27;a&#x27;</span>]=<span class="keyword">new</span> <span class="built_in">treeNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ptr=ptr-&gt;next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ptr-&gt;isEnd=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>数组优化版</p>
<ul>
<li><p>维护代码</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tree[<span class="number">100001</span>][<span class="number">26</span>]&#123;<span class="number">0</span>&#125;,end[<span class="number">100001</span>]&#123;<span class="number">0</span>&#125;,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> push=[&amp;](string _str)&#123;</span><br><span class="line">    <span class="type">int</span> ptr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:_str)&#123;</span><br><span class="line">        <span class="type">int</span> bit=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!tree[ptr][bit])&#123;</span><br><span class="line">            tree[ptr][bit]=++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr=tree[ptr][bit];</span><br><span class="line">    &#125;</span><br><span class="line">    end[ptr]=<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>AC自动机</p>
<ul>
<li><p>细节</p>
<p>  比普通的字典树再引入了fail失配指针辅助维护字典树，以方便匹配字符流。维护fail时，当当前节点是super指针，其子节点若没有指向则将其指向起点：并没有任何一个元素有这样的开始，当前字符相当于多余；若有指向则其失配指针指向super，当其失配时返回super，但其子节点仍未维护。当维护其他节点时其子节点若是没有指向则将其指向当前指针的fail指针的对应位置，若存在则其子节点的fail指针指向当前节点的fail指针的相对位置。当前位置是否存在对应的单词取决于当前位置是否存在单词以及对应fail指针指向是否存在单词。故只需要不断地根据字符移动指针就能找到是否包含这样的单词。fail指针实际上是指当前位置失配后能找到的与之前字符匹配的最长位置。</p>
</li>
<li><p>基本结构</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">treeNode</span>&#123;</span><br><span class="line">    vector&lt;treeNode*&gt;next;</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    treeNode* fail;</span><br><span class="line">    <span class="built_in">treeNode</span>()&#123;</span><br><span class="line">        next.<span class="built_in">resize</span>(<span class="number">26</span>,<span class="literal">nullptr</span>);</span><br><span class="line">        isEnd=<span class="literal">false</span>;</span><br><span class="line">        fail=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本维护方式</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">super=<span class="keyword">new</span> <span class="built_in">treeNode</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;word:words)&#123;</span><br><span class="line">    treeNode *ptr=super;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:word)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ptr-&gt;next[c-<span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">            ptr-&gt;next[c-<span class="string">&#x27;a&#x27;</span>]=<span class="keyword">new</span> <span class="built_in">treeNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ptr=ptr-&gt;next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ptr-&gt;isEnd=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">super-&gt;fail=super;</span><br><span class="line">queue&lt;treeNode*&gt;qu;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(super-&gt;next[i])&#123;</span><br><span class="line">        super-&gt;next[i]-&gt;fail=super;</span><br><span class="line">        qu.<span class="built_in">push</span>(super-&gt;next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        super-&gt;next[i]=super;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    treeNode* cur=qu.<span class="built_in">front</span>();</span><br><span class="line">    qu.<span class="built_in">pop</span>();</span><br><span class="line">    cur-&gt;isEnd|=cur-&gt;fail-&gt;isEnd;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;next[i])&#123;</span><br><span class="line">            cur-&gt;next[i]-&gt;fail=cur-&gt;fail-&gt;next[i];</span><br><span class="line">            qu.<span class="built_in">push</span>(cur-&gt;next[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur-&gt;next[i]=cur-&gt;fail-&gt;next[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>01字典树</p>
<p>  解决数位问题，从高位到低位存储，完成存储与查询。多用于解决异或最大问题，反向存储，贪心地取与当前位异或为1的节点进入。</p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">bitTree</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> val,end;</span><br><span class="line">    vector&lt;bitTree*&gt;child;</span><br><span class="line">    <span class="built_in">bitTree</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val),<span class="built_in">end</span>(<span class="literal">false</span>),<span class="built_in">child</span>(<span class="number">2</span>,<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>字符串编号前缀树</p>
<p>  使用字典树解决字符串编号问题。</p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node *next[<span class="number">26</span>]&#123;&#125;;</span><br><span class="line">    <span class="type">int</span> sid=<span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Node *super=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line"><span class="type">int</span> sid=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> put=[&amp;](string &amp;str)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">    Node *ptr=super;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> &amp;c:str)&#123;</span><br><span class="line">        <span class="type">int</span> idx=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ptr-&gt;next[idx])&#123;</span><br><span class="line">            ptr-&gt;next[idx]=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ptr=ptr-&gt;next[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ptr-&gt;sid==<span class="number">-1</span>)&#123;</span><br><span class="line">        ptr-&gt;sid=sid++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr-&gt;sid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例子</p>
<p>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-cost-to-convert-string-ii/">https://leetcode.cn/problems/minimum-cost-to-convert-string-ii/</a></p>
<p>  该题需要对源字符串和改后字符串进行编号并附加一条有向边，完成floyd最短路的计算。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Node *next[<span class="number">26</span>]&#123;&#125;;</span><br><span class="line">        <span class="type">int</span> sid=<span class="number">-1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minimumCost</span><span class="params">(string source, string target, vector&lt;string&gt;&amp; original, vector&lt;string&gt;&amp; changed, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        Node *super=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        <span class="type">int</span> sid=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> put=[&amp;](string &amp;str)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">            Node *ptr=super;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> &amp;c:str)&#123;</span><br><span class="line">                <span class="type">int</span> idx=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(!ptr-&gt;next[idx])&#123;</span><br><span class="line">                    ptr-&gt;next[idx]=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                ptr=ptr-&gt;next[idx];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ptr-&gt;sid==<span class="number">-1</span>)&#123;</span><br><span class="line">                ptr-&gt;sid=sid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ptr-&gt;sid;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> m=cost.<span class="built_in">size</span>(),m2=m*<span class="number">2</span>,inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">d</span>(m2,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m2,inf));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m2;i++)&#123;</span><br><span class="line">            d[i][i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="type">int</span> u=<span class="built_in">put</span>(original[i]),v=<span class="built_in">put</span>(changed[i]);</span><br><span class="line">            d[u][v]=<span class="built_in">min</span>(d[u][v],cost[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;sid;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sid;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(d[i][k]==inf)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;sid;j++)&#123;</span><br><span class="line">                    d[i][j]=<span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n=source.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> linf=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">        vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;<span class="built_in">mem</span>(n,<span class="number">-1</span>);</span><br><span class="line">        function&lt;<span class="type">long</span> <span class="type">long</span>(<span class="type">int</span>)&gt;dfs=[&amp;](<span class="type">int</span> i)-&gt;<span class="type">long</span> <span class="type">long</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(mem[i]!=<span class="number">-1</span>)<span class="keyword">return</span> mem[i];</span><br><span class="line">            mem[i]=linf;</span><br><span class="line">            <span class="keyword">if</span>(source[i]==target[i])mem[i]=<span class="built_in">dfs</span>(i<span class="number">+1</span>);</span><br><span class="line">            Node *sp=super,*tp=super;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line">                sp=sp-&gt;next[source[j]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                tp=tp-&gt;next[target[j]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">if</span>(!sp||!tp)<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(sp-&gt;sid==<span class="number">-1</span>||tp-&gt;sid==<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> c=d[sp-&gt;sid][tp-&gt;sid];</span><br><span class="line">                <span class="keyword">if</span>(c&lt;inf)&#123;</span><br><span class="line">                    mem[i]=<span class="built_in">min</span>(mem[i],<span class="built_in">dfs</span>(j<span class="number">+1</span>)+c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mem[i];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res=<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res==linf?<span class="number">-1</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="5-滚动哈希"><a href="#5-滚动哈希" class="headerlink" title="5. 滚动哈希"></a>5. 滚动哈希</h2><ul>
<li><p>细节</p>
<p>  将数据如字符串按照某个（某多个）$base$映射到整数域，但这个过程会导致溢出所以需要定义某个（某多个）$mod$将其再映射到支持的大小。单对$base、mod$相当容易冲突，故一般配合双哈希来实现。</p>
<p>  注意：可引入前缀和，但注意低端需要乘对应的$mul$。</p>
</li>
</ul>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><h4 id="A-最长公共子路径"><a href="#A-最长公共子路径" class="headerlink" title="A. 最长公共子路径"></a>A. 最长公共子路径</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subpath/description/">https://leetcode.cn/problems/longest-common-subpath/description/</a></p>
<ul>
<li><p>细节</p>
<p>  多重公共子序列求解。使用二分实现对单一长度的搜索，将所有该长度的字符串按上述方法哈希。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> mod1=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> mod2=<span class="number">1e9</span><span class="number">+9</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pairhash</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; p)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> fn=<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">fn</span>(p.first)&lt;&lt;<span class="number">16</span>)^<span class="built_in">fn</span>(p.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubpath</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=paths.<span class="built_in">size</span>();</span><br><span class="line">        mt19937 gen&#123;random_device&#123;&#125;()&#125;;</span><br><span class="line">        <span class="keyword">auto</span> dis=<span class="built_in">uniform_int_distribution</span>&lt;<span class="type">int</span>&gt;(<span class="number">1e6</span>, <span class="number">1e7</span>);</span><br><span class="line">        <span class="type">int</span> base1=<span class="built_in">dis</span>(gen);</span><br><span class="line">        <span class="type">int</span> base2=<span class="built_in">dis</span>(gen);</span><br><span class="line">        <span class="keyword">auto</span> check=[&amp;](<span class="type">int</span> k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> max_base1=<span class="number">1</span>,max_base2=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">                max_base1=(ll)max_base1*base1%mod1;</span><br><span class="line">                max_base2=(ll)max_base2*base2%mod2;</span><br><span class="line">            &#125;</span><br><span class="line">            unordered_set&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,pairhash&gt;tol;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">                <span class="type">int</span> hash1=<span class="number">0</span>,hash2=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">                    hash1=((ll)hash1*base1+paths[i][j])%mod1;</span><br><span class="line">                    hash2=((ll)hash2*base2+paths[i][j])%mod2;</span><br><span class="line">                &#125;</span><br><span class="line">                unordered_set&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,pairhash&gt;cur;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>||tol.<span class="built_in">count</span>(&#123;hash1,hash2&#125;))&#123;</span><br><span class="line">                    cur.<span class="built_in">emplace</span>(hash1,hash2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=k;j&lt;paths[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    hash1=(((ll)hash1*base1%mod1-(ll)paths[i][j-k]*max_base1%mod1+paths[i][j])+mod1)%mod1;</span><br><span class="line">                    hash2=(((ll)hash2*base2%mod2-(ll)paths[i][j-k]*max_base2%mod2+paths[i][j])+mod2)%mod2;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>||tol.<span class="built_in">count</span>(&#123;hash1,hash2&#125;))&#123;</span><br><span class="line">                        cur.<span class="built_in">emplace</span>(hash1,hash2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                tol=<span class="built_in">move</span>(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">min_element</span>(paths.<span class="built_in">begin</span>(),paths.<span class="built_in">end</span>(),[&amp;](<span class="keyword">auto</span> &amp;p1,<span class="keyword">auto</span> &amp;p2)&#123;</span><br><span class="line">            <span class="keyword">return</span> p<span class="number">1.</span><span class="built_in">size</span>()&lt;p<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        &#125;)-&gt;<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r<span class="number">+1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">                l=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  注:可以以以下方式来完成unordered_map&#x2F;unordered_set对pair的支持。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pair_hash = [fn = <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; o) -&gt; <span class="type">size_t</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> (<span class="built_in">fn</span>(o.first) &lt;&lt; <span class="number">16</span>) ^ <span class="built_in">fn</span>(o.second);</span><br><span class="line">&#125;;</span><br><span class="line">unordered_map&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,<span class="type">int</span>,<span class="keyword">decltype</span>(pair_hash)&gt;<span class="built_in">hash</span>(<span class="number">0</span>,pair_hash);</span><br><span class="line">unordered_set&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,<span class="keyword">decltype</span>(pair_hash)&gt;<span class="built_in">hash</span>(<span class="number">0</span>,pair_hash);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="B-最长公共子路径"><a href="#B-最长公共子路径" class="headerlink" title="B. 最长公共子路径"></a>B. 最长公共子路径</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-duplicate-substring/description/">https://leetcode.cn/problems/longest-duplicate-substring/description/</a></p>
<ul>
<li><p>细节</p>
<p>  找到字符串重复出现的部分，使用二分限制长度，双哈希完成检索。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> mod1=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> mod2=<span class="number">1e9</span><span class="number">+9</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pairhash</span>&#123;</span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; p)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> fn=<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">fn</span>(p.first)&lt;&lt;<span class="number">16</span>)^<span class="built_in">fn</span>(p.second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="function">string <span class="title">longestDupSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        mt19937 gen&#123;random_device&#123;&#125;()&#125;;</span><br><span class="line">        <span class="keyword">auto</span> dis=<span class="built_in">uniform_int_distribution</span>&lt;<span class="type">int</span>&gt;(<span class="number">1e6</span>, <span class="number">1e7</span>);</span><br><span class="line">        <span class="type">int</span> base1=<span class="built_in">dis</span>(gen);</span><br><span class="line">        <span class="type">int</span> base2=<span class="built_in">dis</span>(gen);</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">auto</span> check=[&amp;](<span class="type">int</span> k)&#123;</span><br><span class="line">            <span class="type">int</span> max_base1=<span class="number">1</span>,max_base2=<span class="number">1</span>,hash1=<span class="number">0</span>,hash2=<span class="number">0</span>;</span><br><span class="line">            unordered_set&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,pairhash&gt;hash;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">                max_base1=(ll)max_base1*base1%mod1;</span><br><span class="line">                max_base2=(ll)max_base2*base2%mod2;</span><br><span class="line">                hash1=((ll)hash1*base1+s[i])%mod1;</span><br><span class="line">                hash2=((ll)hash2*base2+s[i])%mod2;</span><br><span class="line">            &#125;</span><br><span class="line">            hash.<span class="built_in">emplace</span>(hash1,hash2);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;n;i++)&#123;</span><br><span class="line">                hash1=(((ll)hash1*base1%mod1-(ll)s[i-k]*max_base1%mod1+s[i])+mod1)%mod1;</span><br><span class="line">                hash2=(((ll)hash2*base2%mod2-(ll)s[i-k]*max_base2%mod2+s[i])+mod2)%mod2;</span><br><span class="line">                <span class="keyword">if</span>(hash.<span class="built_in">count</span>(&#123;hash1,hash2&#125;))&#123;</span><br><span class="line">                    res=s.<span class="built_in">substr</span>(i-k<span class="number">+1</span>,k);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                hash.<span class="built_in">emplace</span>(hash1,hash2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r<span class="number">+1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">                l=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-bitset"><a href="#6-bitset" class="headerlink" title="6. bitset"></a>6. bitset</h2><p>使用<code>bitset</code>模拟确认&#x2F;存在等问题。</p>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><h4 id="A-01背包问题优化"><a href="#A-01背包问题优化" class="headerlink" title="A. 01背包问题优化"></a>A. 01背包问题优化</h4><p>01背包只需要确认每一种可能是否成立，例如最简单的单变量01背包问题：<code>dp[i][j]</code>代指考虑了前<code>i</code>个物品，其价值是否能恰好为<code>j</code>。我们需要维护一个巨大的二维数组，来解决这个问题。但注意到我们只在乎的是<code>dp[i][j]</code>的真值，我们可以维护一个<code>f[j]</code>，来代指是否有满足这个的价值。使用<code>bitset</code>来模拟一个大整数，使用位运算解决该问题。</p>
<p>$$dp[i][j]&#x3D;dp[i-1][j]|dp[i-1][j-v]$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num:nums)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=UPPER_BOUND;j&gt;=num;j--)&#123;</span><br><span class="line">        dp[j]|=dp[j-num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$$f|&#x3D;f&lt;&lt;(UPPER_BOUND-v)&gt;&gt;(UPPER_BOUND-v-v)$$</p>
<p>$j$状态只能从一个$j-v$状态迁移来，而我们需要枚举所有可能的$j$才能完成对此状态的维护，利用位运算，我们可以很轻易得到这一点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;UPPER_BOUND&gt;f&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num:nums)&#123;</span><br><span class="line">    f|=f&lt;&lt;(UPPER_BOUND-num)&gt;&gt;(UPPER_BOUND-num-num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度降为$O(nm&#x2F;w)$，$w$视具体的实现而定。</p>
<h1 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a><strong>梯度下降</strong></h1><p>多为解决k聚类问题。</p>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><ul>
<li><p>找到评价方程</p>
</li>
<li><p>找到评价方程的偏导</p>
</li>
<li><p>梯度更新</p>
</li>
<li><p>向量更新</p>
</li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="A-服务中心的最佳位置"><a href="#A-服务中心的最佳位置" class="headerlink" title="A. 服务中心的最佳位置"></a>A. 服务中心的最佳位置</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-position-for-a-service-centre/">https://leetcode.cn/problems/best-position-for-a-service-centre/</a></p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">getMinDistSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; positions)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> eps=<span class="number">1e-7</span>;</span><br><span class="line">    <span class="type">double</span> lr=<span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> decay=<span class="number">1e-3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n=positions.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> batchSize=n;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> x=<span class="number">0.0</span>,y=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;pos:positions)&#123;</span><br><span class="line">        x+=pos[<span class="number">0</span>];</span><br><span class="line">        y+=pos[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    x/=n;</span><br><span class="line">    y/=n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> cul=[&amp;](<span class="type">double</span> cx,<span class="type">double</span> cy)&#123;</span><br><span class="line">        <span class="type">double</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;pos:positions)&#123;</span><br><span class="line">            res+=<span class="built_in">sqrt</span>((pos[<span class="number">0</span>]-cx)*(pos[<span class="number">0</span>]-cx)+(pos[<span class="number">1</span>]-cy)*(pos[<span class="number">1</span>]-cy));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    mt19937 gen&#123;random_device&#123;&#125;()&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">shuffle</span>(positions.<span class="built_in">begin</span>(),positions.<span class="built_in">end</span>(),gen);</span><br><span class="line">        <span class="type">double</span> px=x,py=y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i+=batchSize)&#123;</span><br><span class="line">            <span class="type">int</span> m=<span class="built_in">min</span>(i+batchSize,n);</span><br><span class="line">            <span class="type">double</span> dx=<span class="number">0.0</span>,dy=<span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> &amp;pos=positions[j];</span><br><span class="line">                <span class="comment">// +eps防止为0</span></span><br><span class="line">                dx+=(x-pos[<span class="number">0</span>])/(<span class="built_in">sqrt</span>((pos[<span class="number">0</span>]-x)*(pos[<span class="number">0</span>]-x)+(pos[<span class="number">1</span>]-y)*(pos[<span class="number">1</span>]-y))+eps);</span><br><span class="line">                dy+=(y-pos[<span class="number">1</span>])/(<span class="built_in">sqrt</span>((pos[<span class="number">0</span>]-x)*(pos[<span class="number">0</span>]-x)+(pos[<span class="number">1</span>]-y)*(pos[<span class="number">1</span>]-y))+eps);</span><br><span class="line">            &#125;</span><br><span class="line">            x-=lr*dx;</span><br><span class="line">            y-=lr*dy;</span><br><span class="line">            lr*=(<span class="number">1</span>-decay);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sqrt</span>((x-px)*(x-px)+(y-py)*(y-py))&lt;eps)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cul</span>(x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="常见思维"><a href="#常见思维" class="headerlink" title="常见思维"></a><strong>常见思维</strong></h1><h2 id="1-前缀和与差分"><a href="#1-前缀和与差分" class="headerlink" title="1. 前缀和与差分"></a>1. 前缀和与差分</h2><p>一次维护，快速获取区间信息（值不可变，值可变选择线段树&#x2F;树状数组）。</p>
<ul>
<li><p>1维</p>
<ul>
<li><p>前缀和</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 维护</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">pre</span>(n<span class="number">+1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    pre[i<span class="number">+1</span>]=pre[i]+nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">int</span> sum_from_x_to_y=pre[y<span class="number">+1</span>]-pre[x];</span><br></pre></td></tr></table></figure>
</li>
<li><p>差分</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 维护</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">diff</span>(n<span class="number">+1</span>);</span><br><span class="line"><span class="comment">// 向[l,r]区间(0~n-1) +d</span></span><br><span class="line">diff[l]+=d;</span><br><span class="line">diff[r<span class="number">+1</span>]+=d<span class="number">+1</span>;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    diff[i]+=diff[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>2维</p>
<ul>
<li><p>前缀和</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 维护</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">pre</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+1</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">        pre[i<span class="number">+1</span>][j<span class="number">+1</span>]=pre[i<span class="number">+1</span>][j]+pre[i][j<span class="number">+1</span>]-pre[i][j]+nums[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">int</span> sum_from_x1y1_to_x2y2=pre[x2<span class="number">+1</span>][y2<span class="number">+1</span>]-pre[x1][y2<span class="number">+1</span>]-pre[x2<span class="number">+1</span>][y1]+pre[x1][y1];</span><br></pre></td></tr></table></figure>
</li>
<li><p>差分</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 维护</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">diff</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+1</span>));</span><br><span class="line"><span class="comment">// 向[(l,r),(l+x,r+x)]区间(0~n-1,0~m-1) +d</span></span><br><span class="line">diff[l][r]++;</span><br><span class="line">diff[l][r+x<span class="number">+1</span>]--;</span><br><span class="line">diff[l+x<span class="number">+1</span>][r]--;</span><br><span class="line">diff[l+x<span class="number">+1</span>][r+x<span class="number">+1</span>]++;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">        diff[i<span class="number">+1</span>][j<span class="number">+1</span>]=diff[i<span class="number">+1</span>][j]+diff[i][j<span class="number">+1</span>]-diff[i][j]+diff[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2. 动态规划"></a>2. 动态规划</h2><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><ul>
<li><p>需要保存什么状态，怎么保存状态（这里可以考虑二进制压缩状态）。</p>
</li>
<li><p>转移方程。 （现态&#x3D;&#x3D;次态，这一步难求的话可以考虑记忆化深搜。）</p>
</li>
<li><p>边界条件。 （初始状态）</p>
</li>
<li><p>根据次态位置确定维护顺序，更有甚者可能结合拓扑排序确定。</p>
</li>
<li><p>滚动数组优化？</p>
</li>
<li><p>答案位置？视维护dp含义所定，过程给出\结尾给出。</p>
<p>  注意区间dp若需要满足非空，则考虑答案只从单一方向维护但dp正常维护。</p>
<p>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-dot-product-of-two-subsequences/">https://leetcode.cn/problems/max-dot-product-of-two-subsequences/</a></p>
</li>
</ul>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><h4 id="A-最长递增子序列问题-LIS-基于二分搜索"><a href="#A-最长递增子序列问题-LIS-基于二分搜索" class="headerlink" title="A. 最长递增子序列问题 LIS (基于二分搜索)"></a>A. 最长递增子序列问题 LIS (基于二分搜索)</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">https://leetcode.cn/problems/longest-increasing-subsequence/</a></p>
<ul>
<li><p>关键点</p>
<p>  维护一个len数组，len[i]代表长度为i的子序列最后一位的最小可能值。由于len[i]一定是单调递增的（否则当前len并不是最优的。），故维护时可以利用二分查找减少时间复杂度。这里pos维护的是上一个可行的位置，l&#x3D;&#x3D;r时可能l也是可行位置故需要再次判断，且能确保len[pos+1]&gt;&#x3D;nums[i]。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxlen=<span class="number">1</span>,n=nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">len</span>(n<span class="number">+1</span>);</span><br><span class="line">    len[maxlen]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;len[maxlen])&#123;</span><br><span class="line">            len[++maxlen]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">1</span>,r=maxlen,pos=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">                <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(len[mid]&lt;nums[i])&#123;</span><br><span class="line">                    pos=mid;</span><br><span class="line">                    l=mid<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    r=mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            len[pos<span class="number">+1</span>]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;len;</span><br><span class="line">    len.<span class="built_in">push_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;len.<span class="built_in">back</span>())&#123;</span><br><span class="line">            len.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> it=<span class="built_in">lower_bound</span>(len.<span class="built_in">begin</span>(),len.<span class="built_in">end</span>(),nums[i]);</span><br><span class="line">            *it=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>相关性质</p>
<ul>
<li>维护一个$pre[i]$与$suf[i]$分别表示以$a[i]$结尾的最大LIS与以$a[i]$开始的最大LIS的大小。</li>
</ul>
</li>
<li><p>如果$pre[i]+suf[i]-1&#x3D;&#x3D;数组LIS$则说明$a[i]$一定出现在某个答案序列当中，否则不出现。</p>
<ul>
<li>当其出现在序列中，且$pre[i]$对所有在某个答案序列中的元素唯一时，$a[i]$一定出现在所有答案序列当中。</li>
</ul>
</li>
<li><p>二维版本</p>
<p>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-columns-to-make-sorted-iii/">https://leetcode.cn/problems/delete-columns-to-make-sorted-iii/</a></p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDeletionSize</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=strs[<span class="number">0</span>].<span class="built_in">size</span>(),m=strs.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> bigger=[&amp;](<span class="type">int</span> pre,<span class="type">int</span> cur)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(strs[i][pre]&gt;strs[i][cur])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">bigger</span>(j,i))dp[i]=<span class="built_in">max</span>(dp[i],dp[j]<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n-*<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(),dp.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="B-背包问题"><a href="#B-背包问题" class="headerlink" title="B. 背包问题"></a>B. 背包问题</h4><h5 id="I-完全背包问题"><a href="#I-完全背包问题" class="headerlink" title="I.完全背包问题"></a>I.完全背包问题</h5><h6 id="a-面试题-08-11-硬币"><a href="#a-面试题-08-11-硬币" class="headerlink" title="a. 面试题 08.11. 硬币"></a>a. 面试题 08.11. 硬币</h6><p>无穷物品问题。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-lcci/">https://leetcode.cn/problems/coin-lcci/</a></p>
<p>对每一个物品，在每一种可能的条件下维护它，而不是在每一种可能的条件维护每一个物品。</p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> coins[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">waysToChange</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i]=dp[i-1]+dp[i-5]+dp[i-10]+dp[i-25]会产生重复 1-5和5-1就会重复</span></span><br><span class="line">    <span class="comment">//每次只考虑一种硬币coin，dp[i]+=dp[i-coins]并计算到底,每次计算都是基于之前的选择</span></span><br><span class="line">    <span class="comment">//dp[0]=1,ans=dp[n]</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n<span class="number">+1</span>);</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> coin:coins)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=coin;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=(<span class="type">long</span> <span class="type">long</span>)(dp[i]+dp[i-coin])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="b-多项式乘法问题"><a href="#b-多项式乘法问题" class="headerlink" title="b. 多项式乘法问题"></a>b. 多项式乘法问题</h6><ul>
<li><p>$(1+x+x^2+…)(1+x^2+x^4)…(1+x^n+x^2n)… &#x3D; res*x^n$ 问题</p>
<p>  将一个物品的权重抽象为一个多项式中的指数，这样可以变为一个物品无限的背包问题，每次考虑将新有的物品加入到之前可能存在的集合当中，奉献新的结果。如此处的$(1+x+x^2+…)(1+x^2+x^4)…(1+x^n+x^2n)… &#x3D; res*x^n$就将权重为1的物品变为了$(1+x+x^2+…)$分别是不选、选一个、选多个。</p>
<p>  对此问题的多项式进行修改可以达成多个不同权重的无限物品最终选取权重的可能数。</p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c1[<span class="number">10010</span>],c2[<span class="number">10010</span>];</span><br><span class="line"><span class="function">ll <span class="title">getVal</span><span class="params">(ll n,ll mod)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* (1+x+x^2+...)(1+x^2+x^4)...(1+x^n+x^2n)... = res*x^n */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        c1[i]=<span class="number">1</span>,c2[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//物品权重</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//开始端点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="comment">//物品选择个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;j+k&lt;=n;k+=i)&#123;</span><br><span class="line">                c2[j+k]=(c2[j+k]+c1[j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//滚动优化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            c1[j]=c2[j],c2[j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c1[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更可以优化为</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[<span class="number">10010</span>];</span><br><span class="line"><span class="function">ll <span class="title">getVal</span><span class="params">(ll n,ll mod)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* (1+x+x^2+...)(1+x^2+x^4)...(1+x^n+x^2n)... = res*x^n */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">            dp[j]=(dp[j-i]+dp[j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多重背包问题变形优化</p>
<p>  假设$x&#x3D;2$，$cnt[x]&#x3D;3$</p>
<p>  下式成立：</p>
<p>  $$f[i+1][j−2]&#x3D;f[i][j−2]+f[i][j−4]+f[i][j−6]+f[i][j−8]$$</p>
<p>  也有下式成立：</p>
<p>  $$f[i+1][j]&#x3D;f[i][j]+f[i][j−2]+f[i][j−4]+f[i][j−6]$$</p>
<p>  故联立两式，有下式：</p>
<p>  $$f[i+1][j]&#x3D;f[i][j]+f[i+1][j-2]-f[i][j-8]$$</p>
<p>  故多更一般的情况来说，下式成立：</p>
<p>  $$f[i+1][j]&#x3D;f[i][j]+f[i+1][j-x]-f[i][j-(cnt[x]+1)*x]$$</p>
<p>  该变形也可以降低复杂度。</p>
<p>  例如：</p>
<p>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-of-sub-multisets-with-bounded-sum/">https://leetcode.cn/problems/count-of-sub-multisets-with-bounded-sum/</a></p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countSubMultisets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num:nums)&#123;</span><br><span class="line">        cnt[num]++;</span><br><span class="line">        sum+=num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;sum)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r=<span class="built_in">min</span>(r,sum);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(r<span class="number">+1</span>);</span><br><span class="line">    dp[<span class="number">0</span>]=cnt[<span class="number">0</span>]<span class="number">+1</span>;</span><br><span class="line">    cnt.<span class="built_in">erase</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bound=<span class="number">0</span>,mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[x,c]:cnt)&#123;</span><br><span class="line">        <span class="keyword">auto</span> next_dp=dp;</span><br><span class="line">        bound=<span class="built_in">min</span>(bound+x*c,r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=x;j&lt;=bound;j++)&#123;</span><br><span class="line">            <span class="comment">// next_dp[j]==dp[j]</span></span><br><span class="line">            next_dp[j]=(next_dp[j]+next_dp[j-x])%mod;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=(c<span class="number">+1</span>)*x)&#123;</span><br><span class="line">                next_dp[j]=(next_dp[j]-dp[j-(c<span class="number">+1</span>)*x]+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp=<span class="built_in">move</span>(next_dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        res=(res+dp[l++])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="II-0-1背包问题"><a href="#II-0-1背包问题" class="headerlink" title="II. 0-1背包问题"></a>II. 0-1背包问题</h5><ul>
<li><p>细节</p>
<p>  0-1背包问题意思是指每一个物品只有取\不取两种可能。而处理此类问题，通常有一个限定的上界，在这个上界限制下求价值和最大。这里的上界不代表其真的用完，只是一个边界。</p>
<p>  当有一个明确的上界时我们初始化时将所有置为0（可以不满的情况）；而当有一个明确的下界时，我们仅将一开始合法的位置置为0，其余全为INF。</p>
</li>
<li><p>例子</p>
<ul>
<li><p>物品价值最大问题（明确上界）</p>
<p>  给定$n$个物品和$1$个背包，以及$n$个物品的信息：重量$w_i$、体积$b_i$、价值$v_i$，背包的最大容量$c$，背包的最大容积$d$。求携带的物品的最大价值。</p>
<ul>
<li><p>细节</p>
<p>  对于每个物品，都只有取或者不取两种方案。</p>
<p>  $dp[i][c][d]&#x3D;\left{\begin{matrix} &amp;dp[i+1][c][d] &amp;c&lt;w_i||d&lt;b_i \<br>  &amp;\max(dp[i+1][c-w_i][d-b_i]+v_i,dp[i+1][c][d]) &amp;other \end{matrix}\right. $</p>
<p>  $dp[i][c][d]$代指考虑$[i,n)$下标的元素、当前剩余容量为c、剩余容积为d的问题的解。</p>
<p>  注意选不上时只能将状态迁移到下一个子问题。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt;<span class="built_in">dp</span>(n<span class="number">+1</span>,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(tw<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(tb<span class="number">+1</span>)));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;w[i];j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=b[i];k&lt;=tb;k++)&#123;</span><br><span class="line">            dp[i][j][k]=dp[i<span class="number">+1</span>][j][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=w[i];j&lt;=tw;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;b[i];k++)&#123;</span><br><span class="line">            dp[i][j][k]=dp[i<span class="number">+1</span>][j][k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=b[i];k&lt;=tb;k++)&#123;</span><br><span class="line">            dp[i][j][k]=<span class="built_in">max</span>(dp[i<span class="number">+1</span>][j-w[i]][k-b[i]]+v[i],dp[i<span class="number">+1</span>][j][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>路径还原</p>
<p>  根据当前状态是由哪一个状态迁移来的确定。</p>
</li>
</ul>
</li>
<li><p>给墙壁刷油漆（明确下界）</p>
<p>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/painting-the-walls/">https://leetcode.cn/problems/painting-the-walls/</a></p>
<ul>
<li><p>问题描述</p>
<p>  给你两个长度为$n$ 下标从 <strong>0</strong> 开始的整数数组 $cost$和 $time$ ，分别表示给 $n$堵不同的墙刷油漆需要的开销和时间。你有两名油漆匠：</p>
<ul>
<li><p>一位需要 <strong>付费</strong> 的油漆匠，刷第 $i$堵墙需要花费$time[i]$单位的时间，开销为 $cost[i]$单位的钱。</p>
</li>
<li><p>一位 <strong>免费</strong> 的油漆匠，刷 <strong>任意</strong> 一堵墙的时间为 $1$ 单位，开销为 $0$ 。但是必须在付费油漆匠 <strong>工作</strong> 时，免费油漆匠才会工作。</p>
</li>
</ul>
<p>  请你返回刷完 $n$ 堵墙最少开销为多少。</p>
</li>
<li><p>细节</p>
<p>  将问题转化为从 $n$个物品中选择体积和至少为 $n $的物品，价值和最小是多少。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">paintWalls</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost, vector&lt;<span class="type">int</span>&gt;&amp; time)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=cost.<span class="built_in">size</span>(),inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>,inf));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][<span class="built_in">max</span>(j-time[i<span class="number">-1</span>]<span class="number">-1</span>,<span class="number">0</span>)]+cost[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="C-树上倍增DP"><a href="#C-树上倍增DP" class="headerlink" title="C. 树上倍增DP"></a>C. 树上倍增DP</h4><ul>
<li><p>树节点的第K个祖先</p>
<ul>
<li><p>细节</p>
<p>  利用$dp[i][j]$代表i节点的第$2^j$个祖先节点</p>
<p>  显然$dp[i][0]&#x3D;parent[i]$</p>
<p>  利用性质$2^{j-1}+2^{j-1}&#x3D;2^j$</p>
<p>  知$dp[i][j]&#x3D;dp[dp[i][j-1]][j-1]$</p>
<p>  寻找第k个祖先节点时：</p>
<ul>
<li><p>首先考虑将k分解成$\sum2^i$</p>
</li>
<li><p>优先低位，依次考虑</p>
</li>
</ul>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeAncestor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;dp;</span><br><span class="line">	<span class="built_in">TreeAncestor</span>(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; parent) &#123;</span><br><span class="line">		dp.<span class="built_in">resize</span>(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			dp[i].<span class="built_in">push_back</span>(parent[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">			<span class="type">bool</span> none=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">				<span class="type">int</span> cur=dp[i][j<span class="number">-1</span>]!=<span class="number">-1</span>?dp[dp[i][j<span class="number">-1</span>]][j<span class="number">-1</span>]:<span class="number">-1</span>;</span><br><span class="line">				dp[i].<span class="built_in">push_back</span>(cur);</span><br><span class="line">				<span class="keyword">if</span>(cur!=<span class="number">-1</span>)none=<span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			j++;</span><br><span class="line">			<span class="keyword">if</span>(none)<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getKthAncestor</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> ret=node,pos=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(k&amp;&amp;ret!=<span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(pos&gt;=dp[ret].<span class="built_in">size</span>())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">if</span>(k&amp;<span class="number">1</span>)ret=dp[ret][pos];</span><br><span class="line">			pos++;</span><br><span class="line">			k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li>时间复杂度:O(nlogn)</li>
</ul>
</li>
</ul>
</li>
<li><p>在传球游戏中最大化函数值</p>
<p>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-value-of-function-in-a-ball-passing-game/">https://leetcode.cn/problems/maximize-value-of-function-in-a-ball-passing-game/</a></p>
<ul>
<li><p>细节</p>
<ul>
<li>在实现的时候将<code>n*logn</code>转变为<code>logn*n</code>增加命中</li>
<li>使用<code>__builtin_clzll()</code>获取前导0的个数，使用<code>__builtin_ctzll()</code>获取后导0的个数</li>
</ul>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">getMaxFunctionValue</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; receiver, <span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前导0的个数</span></span><br><span class="line">    <span class="type">int</span> n=receiver.<span class="built_in">size</span>(),m=<span class="number">64</span>-__builtin_clzll(k);</span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">long</span> <span class="type">long</span>&gt;&gt;&gt;<span class="built_in">dp</span>(m,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">long</span> <span class="type">long</span>&gt;&gt;(n));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][i]=&#123;receiver[i],receiver[i]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m<span class="number">-1</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;[parent,res]=dp[j][i];</span><br><span class="line">            <span class="comment">// 找到第2^j个父节点</span></span><br><span class="line">            <span class="keyword">auto</span> &amp;[p_parent,p_res]=dp[j][parent];</span><br><span class="line">            <span class="comment">// 合并得到2^(j+1)</span></span><br><span class="line">            dp[j<span class="number">+1</span>][i]=&#123;p_parent,res+p_res&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cur=i;</span><br><span class="line">        <span class="type">int</span> ptr=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> x=k;x;x&amp;=x<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// 后导0的个数</span></span><br><span class="line">            <span class="keyword">auto</span> &amp;[parent,res]=dp[__builtin_ctzll(x)][ptr];</span><br><span class="line">            cur+=res;</span><br><span class="line">            ptr=parent;</span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="built_in">max</span>(cur,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="D-最长公共子序列"><a href="#D-最长公共子序列" class="headerlink" title="D. 最长公共子序列"></a>D. 最长公共子序列</h4><ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestSubString</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n1=str<span class="number">1.</span><span class="built_in">size</span>(),n2=str<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(n1<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n2<span class="number">+1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n2;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[i<span class="number">-1</span>]==str2[j<span class="number">-1</span>])dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用</p>
<p>  最短公共超序列</p>
<p>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-common-supersequence/">https://leetcode.cn/problems/shortest-common-supersequence/</a></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">shortestCommonSupersequence</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n1=str<span class="number">1.</span><span class="built_in">size</span>(),n2=str<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(n1<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n2<span class="number">+1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n2;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[i<span class="number">-1</span>]==str2[j<span class="number">-1</span>])dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string sub;</span><br><span class="line">    <span class="type">int</span> ptr1=n1,ptr2=n2;</span><br><span class="line">    <span class="keyword">while</span>(ptr1&gt;<span class="number">0</span>&amp;&amp;ptr2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str1[ptr1<span class="number">-1</span>]==str2[ptr2<span class="number">-1</span>])&#123;</span><br><span class="line">            sub+=str1[ptr1<span class="number">-1</span>];</span><br><span class="line">            ptr1--,ptr2--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dp[ptr1][ptr2]==dp[ptr1][ptr2<span class="number">-1</span>])&#123;</span><br><span class="line">            sub+=str2[ptr2<span class="number">-1</span>];</span><br><span class="line">            ptr2--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sub+=str1[ptr1<span class="number">-1</span>];</span><br><span class="line">            ptr1--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ptr1)sub+=str1[--ptr1];</span><br><span class="line">    <span class="keyword">while</span>(ptr2)sub+=str2[--ptr2];</span><br><span class="line">    <span class="built_in">reverse</span>(sub.<span class="built_in">begin</span>(),sub.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> sub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="E-回文串问题"><a href="#E-回文串问题" class="headerlink" title="E. 回文串问题"></a>E. 回文串问题</h4><ul>
<li><p>细节</p>
<p>  $is[i][j]$代指字符串[i:j]是否是一个回文串。考虑中心出发：$is[i][j]&#x3D;true$的条件是$s[i]&#x3D;&#x3D;[j]$&amp;&amp;$(j-i&lt;&#x3D;1||dp[i+1][j-1])$。由于转移方程的特性，i自底而下，j自左而右。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getPalindromicInfo</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;<span class="built_in">is</span>(n,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i&lt;=<span class="number">1</span>||is[i<span class="number">+1</span>][j<span class="number">-1</span>])&#123;</span><br><span class="line">                    is[i][j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O($n^2$)</p>
</li>
<li><p>空间复杂度：O($n^2$)</p>
</li>
</ul>
</li>
</ul>
<h4 id="F-分组问题"><a href="#F-分组问题" class="headerlink" title="F. 分组问题"></a>F. 分组问题</h4><p>将一个集合分为大小相等的两个不重叠子集。</p>
<ul>
<li><p>细节</p>
<p>  当我们依次遍历集合元素时，将他放在多的一个集合时记为val，将他放在少的一个集合时记为-val，将其丢弃时取为0。将差值的绝对值d作为key，将最小高度h作为value。每次我们先将前一个状态的情况（没有加这个元素之前）存起来，逐个遍历前一个状态的情况，故选取当前元素val放在多的一个集合时就有$dp[d+val]&#x3D;max(dp[d+val],h)$，放在少的集合就有$dp[abs(d-val)]&#x3D;max(dp[abs(d-val)],h+min(val,d))$（abs将总是指向高的和矮的差值）。</p>
</li>
<li><p>代码实现</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">biggestTwoSubSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; rods)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=rods.<span class="built_in">size</span>();</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;dp;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;val:rods)&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;<span class="built_in">pre</span>(dp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[d,h]:pre)&#123;</span><br><span class="line">            dp[val+d]=<span class="built_in">max</span>(dp[val+d],h);</span><br><span class="line">            dp[<span class="built_in">abs</span>(d-val)]=<span class="built_in">max</span>(dp[<span class="built_in">abs</span>(d-val)],h+<span class="built_in">min</span>(val,d));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O($nS$)</p>
</li>
<li><p>空间复杂度：O($nS$)</p>
</li>
</ul>
</li>
</ul>
<h4 id="G-博弈问题"><a href="#G-博弈问题" class="headerlink" title="G. 博弈问题"></a>G. 博弈问题</h4><ul>
<li><p>细节</p>
<p>  考虑当前玩家在当前状态是否能获胜。</p>
</li>
<li><p>例子</p>
<ul>
<li><p>探求两个玩家都最优操作的赢家，利用每个人都希望自己的分数最大的特点，当前得分减去另一个玩家上一次的分数的最大来求解。一般从后往前走，最后谁先手都无所谓，因为是对称的。维护dp[i]是从i之后的元素中先手且最优的得分。</p>
<p>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/stone-game-iii/">https://leetcode.cn/problems/stone-game-iii/</a></p>
</li>
<li><p>对于当前玩家，若当前操作可以导向必败态则当前玩家必胜。每次只考虑当前玩家的情况，而将其他子问题看作是另一个玩家。</p>
<p>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/stone-game-iv/submissions/">https://leetcode.cn/problems/stone-game-iv/submissions/</a></p>
</li>
</ul>
</li>
</ul>
<h4 id="H-最大子段和问题"><a href="#H-最大子段和问题" class="headerlink" title="H. 最大子段和问题"></a>H. 最大子段和问题</h4><ul>
<li><p>标准版</p>
<ul>
<li><p>细节</p>
<p>  使用$dp[i]$代指以$nums[i]$结尾的最大子段。而在考虑将$nums[i]$加入时考虑与之前的连接或自成一段。</p>
<p>  $ dp[i]&#x3D;\max(dp[i-1]+nums[i],nums[i]) $</p>
<p>  $ res&#x3D;\max(dp[i]) $</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dp=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num:nums)&#123;</span><br><span class="line">        dp=<span class="built_in">max</span>(dp+num,num);</span><br><span class="line">        res=<span class="built_in">max</span>(res,dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O($n$)</p>
</li>
<li><p>空间复杂度：O($1$)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>控制下限版<code>len&gt;k</code></p>
<ul>
<li><p>细节</p>
<p>维护最小的，满足要求的区间的前缀和作为左部。</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> ll res=<span class="number">0</span>,pre_min=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=k;j&lt;=n;j++,i++)&#123;</span><br><span class="line">res=<span class="built_in">max</span>(res,pre[j]-pre_min);</span><br><span class="line">pre_min=<span class="built_in">min</span>(pre_min,pre[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>控制上限版<code>len&lt;=k</code></p>
<ul>
<li><p>细节</p>
<p>堆动态维护最小的，满足要求的区间的前缀和作为左部。</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> cmp=[&amp;](<span class="type">int</span> &amp;i,<span class="type">int</span> &amp;j)&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[i]==pre[j])<span class="keyword">return</span> i&gt;j;</span><br><span class="line">    <span class="keyword">return</span> pre[i]&gt;pre[j];</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,<span class="keyword">decltype</span>(cmp)&gt;pq&#123;cmp&#125;;</span><br><span class="line">pq.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()&amp;&amp;i-pq.<span class="built_in">top</span>()&gt;k)&#123;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    res=<span class="built_in">max</span>(res,pre[i]-pre[pq.<span class="built_in">top</span>()]);</span><br><span class="line">    pq.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="I-最大子矩阵和问题"><a href="#I-最大子矩阵和问题" class="headerlink" title="I. 最大子矩阵和问题"></a>I. 最大子矩阵和问题</h4><ul>
<li><p>细节</p>
<p>  $$sum[i_1][j_1][i_2][j_2]&#x3D;\sum_{i&#x3D;i_1}^{i_2}\sum_{j&#x3D;j_1}^{j_2}matrix[i][j]$$</p>
<p>  $$<br>  \begin{aligned}<br>  res&amp;&#x3D;\max_{1&lt;&#x3D;i_1&lt;&#x3D;i_2&lt;&#x3D;n}\max_{1&lt;&#x3D;j_1&lt;&#x3D;j_2&lt;&#x3D;m}sum[i_1][j_1][i_2][j_2]\<br>  &amp;&#x3D;\max_{1&lt;&#x3D;i_1&lt;&#x3D;i_2&lt;&#x3D;n}t[i_1][i_2]<br>  \end{aligned}<br>  $$</p>
<p>  $$<br>  \begin{aligned}<br>  t[i_1][i_2]&amp;&#x3D;\max_{1&lt;&#x3D;j_1&lt;&#x3D;j_2&lt;&#x3D;m}sum[i_1][j_1][i_2][j_2]\<br>  &amp;&#x3D;\max_{1&lt;&#x3D;j_1&lt;&#x3D;j_2&lt;&#x3D;m}\sum_{j&#x3D;j_1}^{j_2}\sum_{i&#x3D;i_1}^{i_2}matrix[i][j]\<br>  &amp;&#x3D;\max_{1&lt;&#x3D;j_1&lt;&#x3D;j_2&lt;&#x3D;m}\sum_{j&#x3D;j_1}^{j_2}b[j]<br>  \end{aligned}<br>  $$</p>
<p>  $$b[j]&#x3D;\sum_{i&#x3D;i_1}^{i_2}matrix[i][j]$$</p>
<p>  这样就将问题转化为求$b[j]$最大子段和的一个过程。枚举行-&gt;选择最大列。</p>
</li>
<li><p>代码实现</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dp=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num:nums)&#123;</span><br><span class="line">        dp=<span class="built_in">max</span>(dp+num,num);</span><br><span class="line">        res=<span class="built_in">max</span>(res,dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubSum2</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;matrix)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n=matrix.<span class="built_in">size</span>(),m=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i1=<span class="number">0</span>;i1&lt;n;i1++)&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">b</span>(m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i2=i1;i2&lt;n;i2++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;m;k++)&#123;</span><br><span class="line">                b[k]+=matrix[i2][k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> maxb=<span class="built_in">maxSubSum</span>(b);</span><br><span class="line">            res=<span class="built_in">max</span>(maxb,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="J-流水作业问题"><a href="#J-流水作业问题" class="headerlink" title="J. 流水作业问题"></a>J. 流水作业问题</h4><ul>
<li><p>细节</p>
<p>  当前有机器$M_1、M_2$，N个作业${1,2,3,…,N}$需要依次经过这两个机器，且其依次需要消耗$A_i、B_i$时间。最好的选择是让$M_1$不断工作，让$M_2$等待或处理。</p>
<p>  假设$T(S,t)$为规模为$S$的作业群需要被加工，此时$M_2$需要等待$t$后才能利用，完成任务群的最短时间。故问题的答案是$T(S,0)$，最终$T(0,t)&#x3D;t$。</p>
<p>  有等式</p>
<p>  $$T(S,t)&#x3D;\min_{i \in S}{T(S-{i},B_i+\max(t-A_i,0)}$$</p>
<p>  假设在最优序列中i任务第一个执行，j任务第二个执行。</p>
<p>  故有</p>
<p>  $$<br>  \begin{aligned}<br>  T(S,t)&amp;&#x3D;A_i+T(S-{i},B_i+\max(t-A_i,0))<br>  \&amp;&#x3D;A_i+A_j+T(S-{i,j},B_j+\max(B_i+\max(t-A_i,0)-A_j,0))<br>  \end{aligned}<br>  $$</p>
<p>  又设<br>  $$<br>  \begin{aligned}<br>  t_{ij}&amp;&#x3D;B_j+\max(B_i+\max(t-A_i,0)-A_j,0)<br>  \&amp;&#x3D;B_j+B_i-A_j+\max(\max(t-A_i,0),A_j-B_i)<br>  \&amp;&#x3D;B_j+B_i-A_j+\max(t-A_i,0,A_j-B_i)<br>  \&amp;&#x3D;B_j+B_i-A_j-A_i+\max(t,A_i,A_j+A_i-B_i)<br>  \end{aligned}<br>  $$</p>
<p>  $t_{i,j}受限于\max(t,A_i,A_j+A_i-B_i)$</p>
<p>  称$\min(B_i,A_j)&gt;&#x3D;\min(B_j,A_i)$为Johnson不等式。</p>
<p>  满足该不等式时</p>
<p>  $$<br>  \begin{aligned}<br>  &amp;\min(B_i,A_j)&gt;&#x3D;\min(B_j,A_i)<br>  \&amp;\Rightarrow \max(-B_i,-A_j)&lt;&#x3D;\max(-B_j,-A_i)<br>  \&amp;\Rightarrow A_i+A_j+\max(-B_i,-A_j)&lt;&#x3D;A_i+A_j+\max(-B_j,-A_i)<br>  \&amp;\Rightarrow \max(A_i+A_j-B_i,A_i)&lt;&#x3D;\max(A_i+A_j-B_j,A_j)<br>  \&amp;\Rightarrow \max(A_i+A_j-B_i,A_i,t)&lt;&#x3D;\max(A_i+A_j-B_j,A_j,t)<br>  \end{aligned}<br>  $$</p>
<p>  故可以知道，$t_{i,j}&lt;&#x3D;t_{j,i}$。</p>
<p>  故当每一个任务都满足Johnson不等式时，一定是最优。</p>
<p>  我们将这些工作分为$N_1&#x3D;{i|A_i&lt;B_i}$，$N_2&#x3D;{i|A_i&gt;&#x3D;B_i}$。将$N_1$按$A_i$递增排序，$N_2$按$B_i$递减排序，以$N_1$+$N_2$作为答案就是最优的。由于$N_1$中$A_i$递增，所以$i&lt;j$ 时$Ai&lt;&#x3D;A_j&lt;B_i$故有$\min(B_i,A_j)&#x3D;A_j&gt;&#x3D;\min(B_j,A_i)$恒成立；对于$N_2$中$B_i$递减，所以$i&lt;j$ 时$A_i&gt;&#x3D;B_i&gt;&#x3D;B_j$故有$\min(B_i,A_j)&gt;&#x3D;\min(B_j,A_i)&#x3D;B_j$恒成立；对于$N_1$的最后一个元素和$N_2$的最前一个元素来说，当$A_i&lt;&#x3D;B_j$时$A_i&lt;&#x3D;B_j&lt;&#x3D;A_j与A_i&lt;B_i$故有$\min(B_i,A_j)&gt;&#x3D;\min(B_j,A_i)&#x3D;A_i$恒成立，反之也是一致。</p>
<p>  由此说明了正确性。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FlowShop</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,vector&lt;<span class="type">int</span>&gt;&amp;B)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=A.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;N1,N2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;B[i])&#123;</span><br><span class="line">            N<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            N<span class="number">2.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(N<span class="number">1.</span><span class="built_in">begin</span>(),N<span class="number">1.</span><span class="built_in">end</span>(),[&amp;](<span class="type">int</span> &amp;idx1,<span class="type">int</span> &amp;idx2)&#123;</span><br><span class="line">        <span class="keyword">return</span> A[idx1]&lt;A[idx2];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">sort</span>(N<span class="number">2.</span><span class="built_in">begin</span>(),N<span class="number">2.</span><span class="built_in">end</span>(),[&amp;](<span class="type">int</span> &amp;idx1,<span class="type">int</span> &amp;idx2)&#123;</span><br><span class="line">        <span class="keyword">return</span> B[idx1]&gt;B[idx2];</span><br><span class="line">    &#125;);</span><br><span class="line">    N<span class="number">1.</span><span class="built_in">insert</span>(N<span class="number">1.</span><span class="built_in">end</span>(),N<span class="number">2.</span><span class="built_in">begin</span>(),N<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> M1t=A[N1[<span class="number">0</span>]],M2t=A[N1[<span class="number">0</span>]]+B[N1[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        M1t+=A[N1[i]];</span><br><span class="line">        M2t=<span class="built_in">max</span>(M1t,M2t)+B[N1[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> M2t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O($nlogn$)</p>
</li>
<li><p>空间复杂度：O($n$)</p>
</li>
</ul>
</li>
</ul>
<h4 id="K-数位DP"><a href="#K-数位DP" class="headerlink" title="K. 数位DP"></a>K. 数位DP</h4><ul>
<li><p>细节</p>
<p>  对一个求边界之内的问题可以考虑数位DP。使用$dp[pos][stats][bound]$来表示当前求解到$pos$位置，而$stats$根据不同问题有不同的取法，但$bound$相对固定：一般以$bound&#x3D;0$来代指当前的状态与上下界没有关系可以任意取（最小-&gt;最大）、$bound&#x3D;1$来代指当前的状态贴着下界（下界-&gt;最大）、$bound&#x3D;2$来代指当前的状态贴着上界（最小-上界）、$bound&#x3D;3$代指当前状态贴着上下界（下界-上界）。</p>
<p>  $bound&#x3D;(00)_b$  可选范围（最小-&gt;最大）</p>
<p>  $bound&#x3D;(01)_b$ 可选范围（下界-&gt;最大）</p>
<p>  $bound&#x3D;(10)_b$ 可选范围（最小-上界）</p>
<p>  $bound&#x3D;(11)_b$ 可选范围（下界-上界）</p>
<p>  低位的1代表当前是否与下界相贴，高位的1代表当前是否与上界相贴。</p>
<p>  故可以有以下操作：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l=(bound&amp;<span class="number">1</span>?low[pos]:MIN);</span><br><span class="line">r=(bound&amp;<span class="number">2</span>?high[pos]:MAX);</span><br><span class="line"></span><br><span class="line">next_bound=(bound&amp;<span class="number">1</span>?cur==low[pos]:<span class="number">0</span>)|(bound&amp;<span class="number">2</span>?(cur==high[pos])&lt;&lt;<span class="number">1</span>:<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>  $stats$的维护依据题目而定。</p>
</li>
</ul>
<h5 id="A-统计范围内X数字的数目"><a href="#A-统计范围内X数字的数目" class="headerlink" title="A. 统计范围内X数字的数目"></a>A. 统计范围内X数字的数目</h5><p>以$1$为例子。</p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">digitOneInNumber</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    string high=<span class="built_in">to_string</span>(num),low=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="type">int</span> n=high.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>((<span class="type">int</span>)low.<span class="built_in">size</span>()&lt;n)&#123;</span><br><span class="line">        low=<span class="string">&#x27;0&#x27;</span>+low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp[pos][stats][bound]</span></span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt;<span class="built_in">dp</span>(n,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">32</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>,<span class="number">-1</span>)));</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)&gt;getDp=[&amp;](<span class="type">int</span> pos,<span class="type">int</span> stats,<span class="type">int</span> bound)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos==n)&#123;</span><br><span class="line">            <span class="keyword">return</span> stats;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[pos][stats][bound]!=<span class="number">-1</span>)<span class="keyword">return</span> dp[pos][stats][bound];</span><br><span class="line">        <span class="type">int</span> MAX=high[pos]-<span class="string">&#x27;0&#x27;</span>,MIN=low[pos]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> l=(bound&amp;<span class="number">1</span>?MIN:<span class="number">0</span>),r=(bound&amp;<span class="number">2</span>?MAX:<span class="number">9</span>);</span><br><span class="line">        dp[pos][stats][bound]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num=l;num&lt;=r;num++)&#123;</span><br><span class="line">            <span class="type">int</span> next_bound=(bound&amp;<span class="number">1</span>?num==MIN:<span class="number">0</span>)|(bound&amp;<span class="number">2</span>?(num==MAX)&lt;&lt;<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> next_stats=stats+(num==<span class="number">1</span>);</span><br><span class="line">            dp[pos][stats][bound]+=<span class="built_in">getDp</span>(pos<span class="number">+1</span>,next_stats,next_bound);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[pos][stats][bound];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getDp</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="B-统计范围内的步进数字数目"><a href="#B-统计范围内的步进数字数目" class="headerlink" title="B. 统计范围内的步进数字数目"></a>B. 统计范围内的步进数字数目</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-stepping-numbers-in-range/description/">https://leetcode.cn/problems/count-stepping-numbers-in-range/description/</a></p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSteppingNumbers</span><span class="params">(string low, string high)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=high.<span class="built_in">size</span>(),mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line">        <span class="keyword">while</span>((<span class="type">int</span>)low.<span class="built_in">size</span>()&lt;n)&#123;</span><br><span class="line">            low=<span class="string">&#x27;0&#x27;</span>+low;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp[pos][stats][bound]</span></span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt;<span class="built_in">dp</span>(n,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>,<span class="number">-1</span>)));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">bool</span>)&gt;getDp=[&amp;](<span class="type">int</span> pos,<span class="type">int</span> stats,<span class="type">int</span> bound,<span class="type">bool</span> isnum)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pos==n)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[pos][stats][bound]!=<span class="number">-1</span>)<span class="keyword">return</span> dp[pos][stats][bound];</span><br><span class="line">            <span class="type">int</span> MAX=high[pos]-<span class="string">&#x27;0&#x27;</span>,MIN=low[pos]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> l=(bound&amp;<span class="number">1</span>?MIN:<span class="number">0</span>),r=(bound&amp;<span class="number">2</span>?MAX:<span class="number">9</span>);</span><br><span class="line">            dp[pos][stats][bound]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(isnum)&#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(stats<span class="number">-1</span>&gt;=<span class="number">0</span>)next.<span class="built_in">push_back</span>(stats<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span>(stats<span class="number">+1</span>&lt;<span class="number">10</span>)next.<span class="built_in">push_back</span>(stats<span class="number">+1</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num:next)&#123;</span><br><span class="line">                    <span class="type">int</span> next_bound=(bound&amp;<span class="number">1</span>?num==MIN:<span class="number">0</span>)|(bound&amp;<span class="number">2</span>?(num==MAX)&lt;&lt;<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(num&lt;=r&amp;&amp;num&gt;=l)&#123;</span><br><span class="line">                        dp[pos][stats][bound]+=<span class="built_in">getDp</span>(pos<span class="number">+1</span>,num,next_bound,isnum);</span><br><span class="line">                        dp[pos][stats][bound]%=mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> num=l;num&lt;=r;num++)&#123;</span><br><span class="line">                    <span class="type">int</span> next_bound=(bound&amp;<span class="number">1</span>?num==MIN:<span class="number">0</span>)|(bound&amp;<span class="number">2</span>?(num==MAX)&lt;&lt;<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">                    dp[pos][stats][bound]+=<span class="built_in">getDp</span>(pos<span class="number">+1</span>,num,next_bound,num!=<span class="number">0</span>);</span><br><span class="line">                    dp[pos][stats][bound]%=mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[pos][stats][bound];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getDp</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="C-找到所有好字符串"><a href="#C-找到所有好字符串" class="headerlink" title="C. 找到所有好字符串"></a>C. 找到所有好字符串</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-good-strings/">https://leetcode.cn/problems/find-all-good-strings/</a></p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findGoodStrings</span><span class="params">(<span class="type">int</span> n, string s1, string s2, string evil)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=evil.<span class="built_in">size</span>(),mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//每次失配时eptr要按next转跳</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> get_next=[&amp;](string _str)-&gt;vector&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">            <span class="type">int</span> _n=_str.<span class="built_in">size</span>(),_ptr=<span class="number">0</span>,_prek=<span class="number">-1</span>;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;_ret(_n<span class="number">+1</span>,<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">while</span>(_ptr&lt;_n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(_prek==<span class="number">-1</span>||_str[_ptr]==_str[_prek])&#123;</span><br><span class="line">                    _ret[++_ptr]=++_prek;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    _prek=_ret[_prek]; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> _ret;</span><br><span class="line">        &#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">next</span>(<span class="built_in">move</span>(<span class="built_in">get_next</span>(evil)));</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">nextmem</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>,<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">auto</span> getNext=[&amp;](<span class="type">int</span> ptr,<span class="type">char</span> cur)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nextmem[ptr][cur-<span class="string">&#x27;a&#x27;</span>]!=<span class="number">-1</span>)<span class="keyword">return</span> nextmem[ptr][cur-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span>(evil[ptr]==cur)<span class="keyword">return</span> ptr<span class="number">+1</span>;</span><br><span class="line">            <span class="type">int</span> prek=ptr;</span><br><span class="line">            <span class="keyword">while</span>(prek!=<span class="number">-1</span>&amp;&amp;evil[prek]!=cur)&#123;</span><br><span class="line">                prek=next[prek];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nextmem[ptr][cur-<span class="string">&#x27;a&#x27;</span>]=prek<span class="number">+1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt;<span class="built_in">dp</span>(n,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>,<span class="number">-1</span>)));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)&gt; getDp=[&amp;](<span class="type">int</span> ptr,<span class="type">int</span> eptr,<span class="type">int</span> bound)&#123;</span><br><span class="line">            <span class="keyword">if</span>(eptr==m)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//匹配完全（子串存在evil）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ptr==n)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dp[ptr][eptr][bound]!=<span class="number">-1</span>)<span class="keyword">return</span> dp[ptr][eptr][bound];</span><br><span class="line"></span><br><span class="line">            dp[ptr][eptr][bound]=<span class="number">0</span>;</span><br><span class="line">            <span class="type">char</span> l=(bound&amp;<span class="number">1</span>?s1[ptr]:<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            <span class="type">char</span> r=(bound&amp;<span class="number">2</span>?s2[ptr]:<span class="string">&#x27;z&#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> ch=l;ch&lt;=r;ch++)&#123;</span><br><span class="line">                <span class="type">int</span> next_eptr=<span class="built_in">getNext</span>(eptr,ch);</span><br><span class="line">                <span class="type">int</span> next_bound=(bound&amp;<span class="number">1</span>?ch==s1[ptr]:<span class="number">0</span>)|(bound&amp;<span class="number">2</span>?(ch==s2[ptr])&lt;&lt;<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">                dp[ptr][eptr][bound]+=<span class="built_in">getDp</span>(ptr<span class="number">+1</span>,next_eptr,next_bound);</span><br><span class="line">                dp[ptr][eptr][bound]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[ptr][eptr][bound];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getDp</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="L-最优搜索二叉树"><a href="#L-最优搜索二叉树" class="headerlink" title="L. 最优搜索二叉树"></a>L. 最优搜索二叉树</h4><p>关注优化方法。</p>
<ul>
<li><p>细节</p>
<p>  假设给定一个二叉树的搜索概率，求解出最优的二叉树结构。搜索二叉树的内点由存在的元素构成，而叶子节点由匹配失败区间组成。如下示意图。</p>
<pre><code>               5
            /     \
         2           6
       /   \       /   \
  (-inf,2) (2,5) (5,6) (6,inf)
</code></pre>
<p>  对于每个结点无论树的结构怎么变，其值都应该是一致的。假设将这些存在的元素标记为$S&#x3D;{x_0,x_1,x_2,x_3,…,x_n}$,而其中的元素之间的间隙就是叶子结点，已知$a_i&#x3D;p_{x&#x3D;(x_{i-1},x_i)}$，$b_i&#x3D;p_{x&#x3D;x_i}$。</p>
<p>  设定$w_{i,j}&#x3D;a_{i-1}+b_i+…+b_j+a_j$，由于$n$个元素有$n+1$个区间，所以$a$会比$b$多一个元素。又设定$p_{i,j}$为到达此子树的平均路径。</p>
<p>  故可以有$w_{i,j}(p_{i,j}-1)&#x3D;w_{i,m-1}p_{i,m-1}+w_{m+1,j}p_{m+1,j}$。一整颗子树的权重是$w_{i,j}$，去除根节点后剩下两颗子树，其产生的开销等于去除到父节点的边的$p_{i,j}$乘以总权重。</p>
<p>  故有$w_{i,j}p_{i,j}&#x3D;w_{i,j}+w_{i,m-1}p_{i,m-1}+w_{m+1,j}p_{m+1,j}$。</p>
<p>  假设$dp[i][j]&#x3D;w_{i,j}p_{i,j}$。</p>
<p>  有转移方程$dp[i][j]&#x3D;w[i][j]+min_{i&lt;&#x3D;k&lt;&#x3D;j}{dp[i][k-1]+dp[k+1][j]}$。$j&lt;i,dp[i][j]&#x3D;0$。</p>
<p>  直接枚举根节点k的时间复杂度显然是$O(n^3)$。</p>
<p>  但显然可以有更优的解法，注意到$dp[i][j]$的两个边界迁移状态是$dp[i][j-1]$、$dp[i+1][j]$，显然$dp[i][j]$与这两个状态相差两端。而对于$dp[i][j-1]$其加入右端后其根节点倾向一定是向右偏以平衡、而$dp[i+1][j]$则相反。只需要检查下图$O$对应位置即可。</p>
<pre><code>  i                 j-1
  [======X===========]
   i+1                 j
    [============X=====]
  i                    j  
  [======OOOOOOOOO=====]  
</code></pre>
<p>  即有：$dp[i][j]&#x3D;w[i][j]+min_{root[i][j-1]&lt;&#x3D;k&lt;&#x3D;root[i+1][j]}{dp[i][k-1]+dp[k+1][j]}$。$j&lt;i,dp[i][j]&#x3D;0$。此时期望复杂度为$O(n^2)$</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 预处理w[i][j] */</span></span><br><span class="line"><span class="comment">// 注意将dp[i][i-1]视作了一子树为空的情况。</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">root</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n)),<span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">max</span>(root[i][j<span class="number">-1</span>],i),r=<span class="built_in">min</span>(root[i<span class="number">+1</span>][j],j);</span><br><span class="line">        root[i][j]=l;</span><br><span class="line">        dp[i][j]=dp[i][l<span class="number">-1</span>]+dp[l<span class="number">+1</span>][j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=l<span class="number">+1</span>;k&lt;=r;k++)&#123;</span><br><span class="line">            <span class="type">int</span> temp=dp[i][k<span class="number">-1</span>]+dp[k<span class="number">+1</span>][j];</span><br><span class="line">            <span class="comment">//等于也划入（减少之后的开销）</span></span><br><span class="line">            <span class="keyword">if</span>(temp&lt;=dp[i][j])&#123;</span><br><span class="line">                dp[i][j]=temp;</span><br><span class="line">                root[i][j]=k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][j]+=w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="M-轮廓线优化"><a href="#M-轮廓线优化" class="headerlink" title="M. 轮廓线优化"></a>M. 轮廓线优化</h4><ul>
<li><p>例子</p>
<p>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-grid-happiness/submissions/">https://leetcode.cn/problems/maximize-grid-happiness/submissions/</a></p>
<ul>
<li><p>细节</p>
<p>  假设按顺序考虑每个格子，那么可以得出对于每个格子，其受其上方、左边的格子影响（每个格子都会被考虑一次）。我们可以保留前n个元素的mask，完成对下一个状态的迭代。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMaxGridHappiness</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> introvertsCount, <span class="type">int</span> extrovertsCount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> _n=<span class="built_in">pow</span>(<span class="number">3</span>,n);</span><br><span class="line">        vector&lt;vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt;&gt;<span class="built_in">dp</span>(m*n<span class="number">+1</span>,vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt;(introvertsCount<span class="number">+1</span>,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(extrovertsCount<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(_n,<span class="number">0x80f0f0f0</span>))));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> score[<span class="number">3</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-60</span>,<span class="number">-10</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-10</span>,<span class="number">40</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> pos=<span class="number">0</span>;pos&lt;m*n;pos++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> mask=<span class="number">0</span>;mask&lt;_n;mask++)&#123;</span><br><span class="line">                <span class="type">int</span> left=mask%<span class="number">3</span>,up=mask*<span class="number">3</span>/_n;</span><br><span class="line">                <span class="keyword">if</span>(pos%n==<span class="number">0</span>)&#123;</span><br><span class="line">                    left=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> in=<span class="number">0</span>;in&lt;=introvertsCount;in++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ex=<span class="number">0</span>;ex&lt;=extrovertsCount;ex++)&#123;</span><br><span class="line">                        <span class="type">int</span> curbit=mask%<span class="number">3</span>,cur=dp[pos][in][ex][mask];</span><br><span class="line">                        <span class="comment">//in</span></span><br><span class="line">                        <span class="keyword">if</span>(in&lt;introvertsCount)&#123;</span><br><span class="line">                            dp[pos<span class="number">+1</span>][in<span class="number">+1</span>][ex][(mask*<span class="number">3</span><span class="number">+1</span>)%_n]=<span class="built_in">max</span>(dp[pos<span class="number">+1</span>][in<span class="number">+1</span>][ex][(mask*<span class="number">3</span><span class="number">+1</span>)%_n],cur<span class="number">+120</span>+score[left][<span class="number">1</span>]+score[up][<span class="number">1</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//ex</span></span><br><span class="line">                        <span class="keyword">if</span>(ex&lt;extrovertsCount)&#123;</span><br><span class="line">                            dp[pos<span class="number">+1</span>][in][ex<span class="number">+1</span>][(mask*<span class="number">3</span><span class="number">+2</span>)%_n]=<span class="built_in">max</span>(dp[pos<span class="number">+1</span>][in][ex<span class="number">+1</span>][(mask*<span class="number">3</span><span class="number">+2</span>)%_n],cur<span class="number">+40</span>+score[left][<span class="number">2</span>]+score[up][<span class="number">2</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//none</span></span><br><span class="line">                        dp[pos<span class="number">+1</span>][in][ex][(mask*<span class="number">3</span>)%_n]=<span class="built_in">max</span>(dp[pos<span class="number">+1</span>][in][ex][(mask*<span class="number">3</span>)%_n],cur);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=introvertsCount;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=extrovertsCount;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> mask=<span class="number">0</span>;mask&lt;_n;mask++)&#123;</span><br><span class="line">                    res=<span class="built_in">max</span>(res,dp[m*n][i][j][mask]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：$O(n^2)$</p>
</li>
<li><p>空间复杂度：$O(n^2)$</p>
</li>
</ul>
</li>
</ul>
<h4 id="N-插入元素DP"><a href="#N-插入元素DP" class="headerlink" title="N. 插入元素DP"></a>N. 插入元素DP</h4><p>从空白&#x2F;特定情况出发，逐步插入元素的最优问题。如下例。</p>
<ul>
<li><p>细节</p>
<p>  每次向数组中取出除头尾的一个元素，其开销为其与左右的乘积。求只剩下2个元素时最小开销。</p>
<p>  $10,1,20,5 \to 10,1,20,5 \to 10,1,5 \to 10,5$的开销为$1150$。</p>
<p>  正向考虑麻烦且复杂，考虑使用动态规划自底向上计算。</p>
<p>  问题与左右边界高度相关，不妨设$dp[i][j]$为$i,j$位置定的情况下最优开销。将中间位置$k$插入后还要考虑将$[i,k]$、$[k,j]$的开销。</p>
<p>  $dp[i][j]&#x3D;min(dp[i][j],dp[i][k]+dp[k][j]+v[i]*v[k]*v[j])$</p>
<p>  注意边界条件的处理。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   vector&lt;vector&lt;ll&gt;&gt;<span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;ll&gt;(n,INF));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	dp[i][i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i<span class="number">+1</span>&lt;n;i++)&#123;</span><br><span class="line">	dp[i][i<span class="number">+1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=i<span class="number">+1</span>;k&lt;j;k++)&#123;</span><br><span class="line">			dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i][k]+dp[k][j]+v[k]*v[i]*v[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：$O(n^3)$</p>
</li>
<li><p>空间复杂度：$O(n^2)$</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-二分搜索"><a href="#3-二分搜索" class="headerlink" title="3. 二分搜索"></a>3. 二分搜索</h2><p>解决寻找单调函数零点问题&#x2F;寻找单调函数最大符合点</p>
<h3 id="A-结合贪心算法找到最大符合点"><a href="#A-结合贪心算法找到最大符合点" class="headerlink" title="A. 结合贪心算法找到最大符合点"></a>A. 结合贪心算法找到最大符合点</h3><p>check函数的维护。</p>
<h3 id="B-基于二分查找的动态规划"><a href="#B-基于二分查找的动态规划" class="headerlink" title="B. 基于二分查找的动态规划"></a>B. 基于二分查找的动态规划</h3><h2 id="4-拓扑排序"><a href="#4-拓扑排序" class="headerlink" title="4. 拓扑排序"></a>4. 拓扑排序</h2><p>解决事件先后发生关系。用单向边依次连接各事件，找到入度为0的点作为起点，再不断加入新的入度为0的点，直到完成遍历。</p>
<h2 id="5-贪心"><a href="#5-贪心" class="headerlink" title="5. 贪心"></a>5. 贪心</h2><h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h3><h4 id="A-Boyer-Moore-投票算法"><a href="#A-Boyer-Moore-投票算法" class="headerlink" title="A. Boyer-Moore 投票算法"></a>A. Boyer-Moore 投票算法</h4><p>筛选大于半数的元素</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element/">https://leetcode.cn/problems/majority-element/</a></p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> candidate = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == candidate)</span><br><span class="line">            ++count;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (--count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            candidate = num;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="B-区间处理-选取最少区间元素覆盖指定区间"><a href="#B-区间处理-选取最少区间元素覆盖指定区间" class="headerlink" title="B. 区间处理-选取最少区间元素覆盖指定区间"></a>B. 区间处理-选取最少区间元素覆盖指定区间</h4><ul>
<li><p>细节</p>
<p>  元素按l从小到大排序，l相同时r从大到小。依次遍历，维护上一次r，每次在可选范围内选取能到最大新r的元素。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//need[0,n]</span></span><br><span class="line"><span class="built_in">sort</span>(range.<span class="built_in">begin</span>(),range.<span class="built_in">end</span>(),[&amp;](vector&lt;<span class="type">int</span>&gt;&amp;v1,vector&lt;<span class="type">int</span>&gt;&amp;v2)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1[<span class="number">0</span>]==v2[<span class="number">0</span>])<span class="keyword">return</span> v1[<span class="number">1</span>]&gt;v2[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> v1[<span class="number">0</span>]&lt;v2[<span class="number">0</span>];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">int</span> ptr=<span class="number">0</span>,res=<span class="number">0</span>,r=<span class="number">0</span>,_n=range.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span>(ptr&lt;_n&amp;&amp;r&lt;n)&#123;</span><br><span class="line">    <span class="type">int</span> bound=r;</span><br><span class="line">    <span class="keyword">while</span>(ptr&lt;_n&amp;&amp;range[ptr][<span class="number">0</span>]&lt;=r)&#123;</span><br><span class="line">        bound=<span class="built_in">max</span>(bound,range[ptr++][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bound&gt;r)&#123;</span><br><span class="line">        r=bound;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r&gt;=n?res:<span class="number">-1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="C-区间处理-选取最少的点使得所有的区间都至少在范围里有一个点"><a href="#C-区间处理-选取最少的点使得所有的区间都至少在范围里有一个点" class="headerlink" title="C. 区间处理-选取最少的点使得所有的区间都至少在范围里有一个点"></a>C. 区间处理-选取最少的点使得所有的区间都至少在范围里有一个点</h4><ul>
<li><p>细节</p>
<p>  元素按l从小到大排序，r无所谓。依次遍历，维护上一次的r，与当前的r取最小，当和上一次的区间不重叠时，加入新的点。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(range.<span class="built_in">begin</span>(),range.<span class="built_in">end</span>(),[&amp;](vector&lt;<span class="type">int</span>&gt;&amp;v1,vector&lt;<span class="type">int</span>&gt;&amp;v2)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1[<span class="number">0</span>]==v2[<span class="number">0</span>])<span class="keyword">return</span> v1[<span class="number">1</span>]&gt;v2[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> v1[<span class="number">0</span>]&lt;v2[<span class="number">0</span>];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">int</span> ptr=<span class="number">0</span>,res=<span class="number">0</span>,prer=<span class="number">-1</span>,n=range.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span>(ptr&lt;n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(prer&gt;=range[ptr][<span class="number">0</span>])&#123;</span><br><span class="line">        prer=<span class="built_in">min</span>(prer,range[ptr][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        prer=range[ptr][<span class="number">1</span>];</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="D-Nim问题"><a href="#D-Nim问题" class="headerlink" title="D. Nim问题"></a>D. Nim问题</h4><ul>
<li><p>问题阐述</p>
<p>  Nim问题是一种经典的博弈论问题，它的规则是这样的：有若干堆石子，每堆石子的数量都是有限的，两个玩家轮流从其中的一堆取石子，每次至少取一颗，最多可以取完当前堆，无法继续取石子的玩家输掉游戏。</p>
</li>
<li><p>细节</p>
<p>  这个问题可以化简为异或是否为0的问题，当所有元素异或为0时为必败态，否则为必赢态。证明如下：</p>
<ol>
<li>当所有堆都为0时显然是一个必败态。</li>
<li>假设当所有小于n个石子的局面都成立。</li>
<li>对于任意一个大于n的局面且异或值不为0的状态：我们要找到该玩家的一个合法操作使另一个玩家变成必败态，而必败态无论如何操作都会令另一玩家处于必胜态。而前者可以通过寻找当前异或值的最高位1并找到这个值，将该值变化为导致异或为0。</li>
</ol>
<p>  故可知：当异或值Nim和为0时玩家必败，非零时必胜。</p>
</li>
</ul>
<h4 id="E-阶梯Nim问题"><a href="#E-阶梯Nim问题" class="headerlink" title="E. 阶梯Nim问题"></a>E. 阶梯Nim问题</h4><ul>
<li><p>问题阐述</p>
<p>  石子在若干个阶梯上，玩家每次只能将一层的若干石子搬到下一层，直到全部石子都搬到了第0层。</p>
</li>
<li><p>细节</p>
<ul>
<li><p>偶数阶不影响问题的结果</p>
</li>
<li><p>对奇数阶异或为0为必败态</p>
</li>
</ul>
</li>
</ul>
<h2 id="6-数组处理"><a href="#6-数组处理" class="headerlink" title="6. 数组处理"></a>6. 数组处理</h2><h3 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h3><h4 id="A-获取k位最大字典序子序列"><a href="#A-获取k位最大字典序子序列" class="headerlink" title="A. 获取k位最大字典序子序列"></a>A. 获取k位最大字典序子序列</h4><ul>
<li><p>细节</p>
<p>  应用单调栈的思想，将尽量大的数字放在前面-&gt;单调递减的栈。但最大抛弃数字是n-size，当不能抛弃数字的时候注意不进行单调处理。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> getMaxSub=[&amp;](vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> size)-&gt;vector&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">ret</span>(size);</span><br><span class="line">    <span class="type">int</span> _n=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> top=<span class="number">-1</span>,cnt=_n-size;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;_n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(top&gt;=<span class="number">0</span>&amp;&amp;ret[top]&lt;nums[i]&amp;&amp;cnt&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            top--;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top&lt;size<span class="number">-1</span>)&#123;</span><br><span class="line">            ret[++top]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O(n)</p>
</li>
<li><p>空间复杂度：O(n)</p>
</li>
</ul>
</li>
</ul>
<h4 id="B-合并两个数组获得最大字典序"><a href="#B-合并两个数组获得最大字典序" class="headerlink" title="B. 合并两个数组获得最大字典序"></a>B. 合并两个数组获得最大字典序</h4><p>字符串也有对应的操作。</p>
<ul>
<li><p>分析</p>
<p>  维护两个指针ptr1、ptr2，对应当前两个数组最前端位置。nums1[ptr1]!&#x3D;nums2[ptr2]时，选择最大的一个是最优的；但当nums1[ptr1]&#x3D;&#x3D;nums2[ptr2]时，需要继续比对，看哪一边能先取得最大的，这就导致了大的能更快被取到。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> compareArrByStartIndex=[&amp;](vector&lt;<span class="type">int</span>&gt;&amp;v1,<span class="type">int</span> idx1,vector&lt;<span class="type">int</span>&gt;&amp;v2,<span class="type">int</span> idx2)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">    <span class="type">int</span> n1=v<span class="number">1.</span><span class="built_in">size</span>(),n2=v<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(idx1&lt;n1&amp;&amp;idx2&lt;n2)&#123;</span><br><span class="line">        <span class="type">int</span> diff=v1[idx1]-v2[idx2];</span><br><span class="line">        <span class="keyword">if</span>(diff!=<span class="number">0</span>)<span class="keyword">return</span> diff;</span><br><span class="line">        idx1++,idx2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n1-idx1)-(n2-idx2);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> merge2=[&amp;](vector&lt;<span class="type">int</span>&gt;&amp;v1,vector&lt;<span class="type">int</span>&gt;&amp;v2)-&gt;vector&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line">    <span class="type">int</span> n1=v<span class="number">1.</span><span class="built_in">size</span>(),n2=v<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(!n1)<span class="keyword">return</span> v2;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!n2)<span class="keyword">return</span> v1;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">ret</span>(n1+n2);</span><br><span class="line">    <span class="type">int</span> ptr1=<span class="number">0</span>,ptr2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n1+n2;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">compareArrByStartIndex</span>(v1,ptr1,v2,ptr2)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            ret[i]=v1[ptr1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ret[i]=v2[ptr2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O($n_1n_2$)</p>
</li>
<li><p>空间复杂度：O($n_1n_2$)</p>
</li>
</ul>
</li>
</ul>
<h4 id="C-满足一定条件的连续子数组"><a href="#C-满足一定条件的连续子数组" class="headerlink" title="C. 满足一定条件的连续子数组"></a>C. 满足一定条件的连续子数组</h4><ul>
<li><p>当连续子数组要求的性质具有一定的单调性，则使用滑动窗口。</p>
</li>
<li><p>使用记录前缀的方式来维护数目。</p>
</li>
</ul>
<h4 id="D-最小的第k个数"><a href="#D-最小的第k个数" class="headerlink" title="D. 最小的第k个数"></a>D. 最小的第k个数</h4><ul>
<li><p>细节</p>
<p>  将数组分为多个大小为5的元素，对其排序后得到中位数，再找到中位数的中位数，此时至少可以排除30%的答案，再进入子问题。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==x)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[r]&gt;x)&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[l]=nums[r];</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[l]&lt;x)&#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[r]=nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[l]=x;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PickNumK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r-l&lt;<span class="number">75</span>)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>()+l,nums.<span class="built_in">begin</span>()+r);</span><br><span class="line">        <span class="keyword">return</span> nums[l+k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(r-k<span class="number">-4</span>)/<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>()+l+i*<span class="number">5</span>,nums.<span class="built_in">begin</span>()+l+i*<span class="number">5</span><span class="number">+4</span>);</span><br><span class="line">        <span class="built_in">swap</span>(nums[l+i*<span class="number">5</span><span class="number">+2</span>],nums[l+i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x=<span class="built_in">PickNumK</span>(nums,(r-l<span class="number">+6</span>)/<span class="number">10</span>,l,l+(r-l<span class="number">-4</span>)/<span class="number">5</span>);</span><br><span class="line">    <span class="type">int</span> idx=<span class="built_in">Partition</span>(nums,x),size=idx-l<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">if</span>(size&gt;=k)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PickNumK</span>(nums,k,l,idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PickNumK</span>(nums,k-size,idx<span class="number">+1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="D-逆数对问题"><a href="#D-逆数对问题" class="headerlink" title="D. 逆数对问题"></a>D. 逆数对问题</h4><p>将一个数组中$nums[i]&gt;nums[j]$且$i&lt;j$的一对$(i,j)$叫做逆数对。</p>
<p>这类问题可以抽象为冒泡排序的比较次数计算、将元素依次移动的开销计算。</p>
<ul>
<li><p>细节</p>
<p>  对于每一个元素，其需要计算其左边的元素有多少个比他大，朴素的思想为$O(n^2)$。但我们考虑到每次和左边比较，其中有很多多余的比较。可以利用归并排序的方法，利用合并的操作完成计数。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; tmp, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l&gt;=r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> inv_count=<span class="built_in">mergeSort</span>(nums,tmp,l,mid)+<span class="built_in">mergeSort</span>(nums, tmp,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="type">int</span> i=l,j=mid<span class="number">+1</span>,pos=l;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&lt;=nums[j])&#123;</span><br><span class="line">            tmp[pos]=nums[i];</span><br><span class="line">            ++i;</span><br><span class="line">            inv_count+=(j-(mid<span class="number">+1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[pos]=nums[j];</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        ++pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k=i;k&lt;=mid;++k) &#123;</span><br><span class="line">        tmp[pos++]=nums[k];</span><br><span class="line">        inv_count+=(j-(mid<span class="number">+1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k=j;k&lt;=r;++k) &#123;</span><br><span class="line">        tmp[pos++]=nums[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(tmp.<span class="built_in">begin</span>()+l,tmp.<span class="built_in">begin</span>()+r<span class="number">+1</span>,nums.<span class="built_in">begin</span>()+l);</span><br><span class="line">    <span class="keyword">return</span> inv_count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">tmp</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mergeSort</span>(nums,tmp,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O($nlogn$)</p>
</li>
<li><p>空间复杂度：O($nlogn$)</p>
</li>
</ul>
</li>
</ul>
<h4 id="E-两个数组中第K对最小和"><a href="#E-两个数组中第K对最小和" class="headerlink" title="E. 两个数组中第K对最小和"></a>E. 两个数组中第K对最小和</h4><p>从两个数组中各选择一个元素以至于其和为所有可以选出来的对中第k小的。</p>
<ul>
<li><p>细节</p>
<p>  事实上我们显然可以先将两个数组都排列，并将一个数组叫做$f$，一个数组叫做$g$。对于$(f[0]+g[0])…(f[i]+g[0])…(f[n-1]+g[0])$他们也是递增的。而下一个最小的可能出现在$f[0]+g[1]$及其余的$(f[1]+g[0])…(f[i]+g[0])…(f[n-1]+g[0])$之中。而每次我们只需要取出最小的就是答案。我们可以选择使用最小堆来维护$tuple&lt;sum,i,j&gt;$分别指代对的和、$f$的第几个元素、$g$的第几个元素。每次取出时将j++后放入。而可以看到维护次数与$k$、$g.size()$相关，所以我们将元素多的数组作为$f$。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function&lt;vector&lt;<span class="type">int</span>&gt;(vector&lt;<span class="type">int</span>&gt;&amp;,vector&lt;<span class="type">int</span>&gt;&amp;)&gt;getRes=[&amp;](vector&lt;<span class="type">int</span>&gt;&amp;f,vector&lt;<span class="type">int</span>&gt;&amp;g,<span class="type">int</span> k)-&gt;vector&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(f.<span class="built_in">size</span>()&gt;g.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getRes</span>(g,f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n=f.<span class="built_in">size</span>(),m=g.<span class="built_in">size</span>();</span><br><span class="line">    priority_queue&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,greater&lt;&gt;&gt;pq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(f[i]+g[<span class="number">0</span>],i,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">    <span class="keyword">while</span>(k--&amp;&amp;!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [sum,i,j]=pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(sum);</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;m)&#123;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(f[i]+g[j],i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意</p>
<p>  也可以用二分方法搜索和的数目、再使用双指针来维护该和下有的对数。</p>
<p>  当变为多个数组的k对和时，可以重复多次此操作来达成。</p>
</li>
<li><p>分析</p>
<ul>
<li><p>时间复杂度：O($l_f+k\log{l_f}$)</p>
</li>
<li><p>空间复杂度：O($k$)</p>
</li>
</ul>
</li>
</ul>
<h4 id="F-下一个排列"><a href="#F-下一个排列" class="headerlink" title="F. 下一个排列"></a>F. 下一个排列</h4><ul>
<li><p>细节</p>
<p>  每次总是想要选择末尾最小的去替换一个末尾刚好比自己大的。于是有以下算法。</p>
<ul>
<li><p>找到 最大下标$i$，使得$1 &lt;&#x3D; i &lt; s.length-1$且$s[i] &gt;&#x3D; s[i - 1]$。</p>
</li>
<li><p>找到 最大下标$j$，使得$i &lt;&#x3D; j &lt; s.length$且对于所有在闭区间$[i, j]$之间的$k$都有$s[k] &gt;&#x3D; s[i - 1]$。</p>
</li>
<li><p>交换下标为$i - 1$和 j$处的两个字符。</p>
</li>
<li><p>将下标$i$开始的字符串后缀反转。</p>
</li>
</ul>
<p>  反过来也可以实现：</p>
<ul>
<li><p>找到 最大下标$i$，使得$1 &lt;&#x3D; i &lt; s.length$且$s[i] &lt; s[i - 1]$。</p>
</li>
<li><p>找到 最大下标$j$，使得$i &lt;&#x3D; j &lt; s.length$且对于所有在闭区间$[i, j]$之间的$k$都有$s[k] &lt; s[i - 1]$。</p>
</li>
<li><p>交换下标为$i - 1$和 j$处的两个字符。</p>
</li>
<li><p>将下标$i$开始的字符串后缀反转。</p>
</li>
</ul>
</li>
<li><p>代码实现</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;=nums[i<span class="number">+1</span>])&#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j&gt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;=nums[j]) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+i<span class="number">+1</span>,nums.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-单调栈"><a href="#7-单调栈" class="headerlink" title="7. 单调栈"></a>7. 单调栈</h2><p>维护一个单调的栈，利用它的性质维护更多信息。</p>
<h3 id="例子-6"><a href="#例子-6" class="headerlink" title="例子"></a>例子</h3><h4 id="A-左（右）侧最近比自己小（大）的元素位置"><a href="#A-左（右）侧最近比自己小（大）的元素位置" class="headerlink" title="A. 左（右）侧最近比自己小（大）的元素位置"></a>A. 左（右）侧最近比自己小（大）的元素位置</h4><p>以左侧最近比自己小的元素为例。维护一个下标对应值单调递增的栈。从左到右，从右到左都一样，只是两者维护答案的时机不同，以及是否将等号放入。</p>
<p>其他情况也同理，找最近小的元素就递增，找最近大的元素就递减。</p>
<ul>
<li>代码实现</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> getArrInfo=[&amp;](vector&lt;<span class="type">int</span>&gt;&amp;nums)-&gt;vector&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line">    <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">ret</span>(n,<span class="number">-1</span>);</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;stk;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()&amp;&amp;nums[stk.<span class="built_in">top</span>()]&gt;=nums[i])&#123;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            ret[i]=stk.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        stk.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> getArrInfo=[&amp;](vector&lt;<span class="type">int</span>&gt;&amp;nums)-&gt;vector&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line">    <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">ret</span>(n,<span class="number">-1</span>);</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;stk;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()&amp;&amp;nums[stk.<span class="built_in">top</span>()]&gt;nums[i])&#123;</span><br><span class="line">            ret[stk.<span class="built_in">top</span>()]=i;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        stk.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="B-二维偏序问题"><a href="#B-二维偏序问题" class="headerlink" title="B. 二维偏序问题"></a>B. 二维偏序问题</h4><ul>
<li><p>问题描述</p>
<p>  有二维数值点集$S_{val}$，二维目标点集$S_{target}$，要求找到$&lt;x_i,y_i&gt; \in S_{target}$在$S_{val}$中，满足$x&gt;&#x3D;x_i &amp;&amp; y&gt;&#x3D;y_i$的最大$x+y$，若没有答案则为-1。</p>
<p>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-sum-queries/">https://leetcode.cn/problems/maximum-sum-queries/</a></p>
</li>
<li><p>思路</p>
<p>  对$x$维度从大到小维护，$x$一致时对$y$维度从大到小维护，其次对数值点集优先维护。</p>
<p>  当我们维护一个点时：</p>
<ul>
<li><p>其之前的点一定满足$x_{pre}&gt;&#x3D;x_{cur}$</p>
</li>
<li><p>对于一个$y$，我们维护一个$y$递增而$x+y$递减的单调栈</p>
<ul>
<li><p>当前维护的$y$小于等于栈顶的元素，这个元素由于$x$的递减特性，其不可能优于当前的栈顶，忽略。</p>
</li>
<li><p>当前维护的$y$大于栈顶的元素，若栈顶元素的$x+y$小于当前的，栈顶元素不可能比当前的元素对之后$x$更小的元素更优，栈顶弹出，直到不满足这个条件。</p>
</li>
</ul>
</li>
</ul>
<p>  之后我们维护到一个目标点时，检查栈中第一个大于目标点$y$的元素对应的$x+y$就是答案。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maximumSumQueries</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums<span class="number">1.</span><span class="built_in">size</span>(),m=queries.<span class="built_in">size</span>(),ptr=<span class="number">0</span>;</span><br><span class="line">        vector&lt;pair&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,<span class="type">int</span>&gt;&gt;<span class="built_in">point</span>(m+n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            point[ptr++]=&#123;&#123;nums1[i],nums2[i]&#125;,-(nums1[i]+nums2[i])&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            point[ptr++]=&#123;&#123;queries[i][<span class="number">0</span>],queries[i][<span class="number">1</span>]&#125;,i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(point.<span class="built_in">begin</span>(),point.<span class="built_in">end</span>(),[&amp;](pair&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,<span class="type">int</span>&gt;&amp;p1,pair&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,<span class="type">int</span>&gt;&amp;p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p<span class="number">1.f</span>irst.first==p<span class="number">2.f</span>irst.first)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p<span class="number">1.f</span>irst.second==p<span class="number">2.f</span>irst.second)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(p<span class="number">1.</span>second&lt;<span class="number">0</span>&amp;&amp;p<span class="number">2.</span>second&gt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(p<span class="number">1.</span>second&gt;=<span class="number">0</span>&amp;&amp;p<span class="number">2.</span>second&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> p<span class="number">1.f</span>irst.second&gt;p<span class="number">2.f</span>irst.second;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p<span class="number">1.f</span>irst.first&gt;p<span class="number">2.f</span>irst.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">res</span>(m,<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// stk存储y递增x+y递减的存在点</span></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;stk;</span><br><span class="line">        <span class="comment">// 按x从大到小维护 优先维护存在点集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[p,w]:point)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// x从大到小 y小了一定不是更优的 没必要维护</span></span><br><span class="line">                <span class="keyword">if</span>(!stk.<span class="built_in">empty</span>()&amp;&amp;stk.<span class="built_in">back</span>().first&gt;=p.second)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    w=-w;</span><br><span class="line">                    <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()&amp;&amp;stk.<span class="built_in">back</span>().second&lt;=w)&#123;</span><br><span class="line">                        stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    stk.<span class="built_in">push_back</span>(&#123;p.second,w&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> l=<span class="number">0</span>,r=stk.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(stk[mid].first&lt;p.second)&#123;</span><br><span class="line">                        l=mid<span class="number">+1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        r=mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(l&lt;stk.<span class="built_in">size</span>()&amp;&amp;stk[l].first&gt;=p.second)&#123;</span><br><span class="line">                    res[w]=stk[l].second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-单调队列"><a href="#8-单调队列" class="headerlink" title="8. 单调队列"></a>8. 单调队列</h2><p>处理左右极值但有期限的情况。当需要左端最大k个位置的最大值-&gt;维护一个单调递减的队列，需要时先将出端过期数据抛弃直到找到答案，其次从后端维护队列的单调性。</p>
<h3 id="例子-7"><a href="#例子-7" class="headerlink" title="例子"></a>例子</h3><h4 id="A-带限制的子序列和"><a href="#A-带限制的子序列和" class="headerlink" title="A. 带限制的子序列和"></a>A. 带限制的子序列和</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/constrained-subsequence-sum/">https://leetcode.cn/problems/constrained-subsequence-sum/</a></p>
<p>带单调队列辅助维护的动态规划解法</p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">constrainedSubsetSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n);</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> ret=nums[<span class="number">0</span>];</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;(i-q.<span class="built_in">front</span>())&gt;k)&#123;</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i]=nums[i]+<span class="built_in">max</span>(dp[q.<span class="built_in">front</span>()],<span class="number">0</span>);</span><br><span class="line">        ret=<span class="built_in">max</span>(ret,dp[i]);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;dp[i]&gt;=dp[q.<span class="built_in">back</span>()])&#123;</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="B-窗口中最大值"><a href="#B-窗口中最大值" class="headerlink" title="B. 窗口中最大值"></a>B. 窗口中最大值</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">https://leetcode.cn/problems/sliding-window-maximum/</a></p>
<ul>
<li><p>细节</p>
<p>  维护一个单调双端队列，每次新插入元素时从尾部插入：当尾部元素严格较小时弹出该元素直到前一个元素大于等于新元素或前方已没有元素。每次去除窗口前端元素时与队列最前方元素作比较：若该元素等于队列前端元素则弹出该元素（这里保证最前面的一定是最大的，窗口前端元素只能小于等于队列前端元素，当它小于的时候，对整个窗口的最大值并没有影响）。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nums.<span class="built_in">size</span>())<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;help;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!help.<span class="built_in">empty</span>()&amp;&amp;help.<span class="built_in">back</span>()&lt;nums[i])&#123;</span><br><span class="line">            help.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        help.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;ret;</span><br><span class="line">    ret.<span class="built_in">push_back</span>(help.<span class="built_in">front</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!help.<span class="built_in">empty</span>()&amp;&amp;help.<span class="built_in">back</span>()&lt;nums[i])&#123;</span><br><span class="line">            help.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        help.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(nums[i-k]==help.<span class="built_in">front</span>())&#123;</span><br><span class="line">            help.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(help.<span class="built_in">front</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="C-找到最大非递减数组的长度"><a href="#C-找到最大非递减数组的长度" class="headerlink" title="C. 找到最大非递减数组的长度"></a>C. 找到最大非递减数组的长度</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-maximum-non-decreasing-array-length/">https://leetcode.cn/problems/find-maximum-non-decreasing-array-length/</a></p>
<ul>
<li><p>细节</p>
<p>  假设$dp[i]$为前$i$个元素构成的最大答案，注意到总是可以将新的数放入上一次的最后一个数，所以$dp$是不减的。</p>
<p>  假设$m[i]$为前$i$个元素在构成答案的最后一个元素的最小值，我们总是期望这个值越小越好。</p>
<p>  故有$dp[i]&#x3D;max^j_{sum[i]-sum[j]&gt;&#x3D;m[j]}(dp[j])+1$。</p>
<p>  又注意到$sum[i]-sum[j]&gt;&#x3D;m[j]$等效于$sum[i]&gt;&#x3D;m[j]+sum[j]$，故一个简单的想法是维护满足区间的最大$dp$，但实现需要考虑值域，限制较大。</p>
<p>  注意到$j&gt;k$和$m[j]+sum[j]&lt;&#x3D;m[k]+sum[k]$同时满足的时候，$j$一定更优，故考虑维护一个单调队列$j$递增、$sum[j]+m[j]$递增。</p>
<p>  在维护一个新状态时，我们总是考虑队首最后一个满足条件的$j$（$dp$不减特性）。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMaximumLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dp[i]为前i个元素构成的最大答案</span></span><br><span class="line">    <span class="comment">// m[i]为在构成答案的最后一个元素的最小值</span></span><br><span class="line">    <span class="comment">// dp[i]=max[when sum[i]-sum[j]&gt;=m[j]](dp[j])+1</span></span><br><span class="line">    <span class="comment">// sum[i]-sum[j]&gt;=m[j] =&gt; sum[i]&gt;=m[j]+sum[j]</span></span><br><span class="line">    <span class="comment">// 故可以用线段树维护&lt;=sum[i]里的m[j]+sum[j]最大dp[x]</span></span><br><span class="line">    <span class="comment">// 考虑到dp是不减的</span></span><br><span class="line">    <span class="comment">// 在满足j&gt;k&amp;&amp;m[j]+sum[j]&lt;=m[k]+sum[k]的情况下 j一定优于k</span></span><br><span class="line">    <span class="comment">// 维护一个单调队列 j递增、sum[j]+m[j]递增</span></span><br><span class="line">    <span class="comment">// 每次只需要去除无用的 取队首</span></span><br><span class="line">    <span class="comment">// 我们想要的是m尽可能小 又由于sum递增 故j越大 相对m越小</span></span><br><span class="line">    <span class="comment">// 故选队首最后一个满足的维护</span></span><br><span class="line">    <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;<span class="built_in">sum</span>(n<span class="number">+1</span>),<span class="built_in">m</span>(n<span class="number">+1</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n<span class="number">+1</span>),<span class="built_in">dq</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="comment">// 保证只有n个元素可能入队</span></span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;sum[dq[l<span class="number">+1</span>]]+m[dq[l<span class="number">+1</span>]]&lt;=sum[i])&#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i]=dp[dq[l]]<span class="number">+1</span>;</span><br><span class="line">        m[i]=sum[i]-sum[dq[l]];</span><br><span class="line">        <span class="keyword">while</span>(r&gt;=l&amp;&amp;sum[dq[r]]+m[dq[r]]&gt;=sum[i]+m[i])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        dq[++r]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-分治"><a href="#9-分治" class="headerlink" title="9. 分治"></a>9. 分治</h2><p>将问题细化为若干个子问题（子问题的处理方式一致），直到找到易于解决的子问题直接返回结果，再依次对该阶段的子问题进行合并导出最终答案。有时候单一变量无法准确形容状态时提升维度。</p>
<ul>
<li><p>例子</p>
<ul>
<li><p>归并排序</p>
<p>  不断分解数组大小，直到只剩下一个元素之后依次归并，完成排序。</p>
</li>
<li><p>L型骨牌填充</p>
<p>  将对应空缺区域单独处理，区域3个区域在中间置L型骨牌充当空缺区域，导致4个子问题完全一致。</p>
</li>
<li><p>整数划分</p>
<p>  设$q(n,m)$为将数字n分为不大于m的数字的若干个数、令这些数字之和为n的可行数目。这样就有一般情况下$q(n,m)&#x3D;q(n-m,m),q(n,m-1)$分别是存在数字m和不存在数字m两种情况；当$n&#x3D;&#x3D;m$时有$q(n,n)&#x3D;q(n,m-1)+1$。</p>
<ul>
<li>这个问题也可以看作是背包问题！每个数字的权重是他本身且数目无限。</li>
</ul>
</li>
<li><p>集合划分</p>
<p>  设$q(n,m)$为将元素各异的数目为n的集合分为m个集合的可行数目。这样一般情况下有$q(n,m)&#x3D;q(n-1,m-1),m*q(n-1,m)$分别是将一个元素单独为一组和将其分入其余任一一组中。</p>
</li>
</ul>
</li>
</ul>
<h2 id="10-递归"><a href="#10-递归" class="headerlink" title="10. 递归"></a>10. 递归</h2><p>计算出边界条件，假设规模为n之前的问题已经解决，考察$f(n)$的取法。</p>
<ul>
<li><p>例子</p>
<ul>
<li><p>男女排队问题</p>
<ul>
<li><p>问题描述</p>
<p> 在这个排队中，女生不能单独出现，只能两个以上的女生出现在序列中。</p>
</li>
<li><p>细节</p>
<p>  对于当n足够大时我们已经获取到之前的信息，对于$f(n)$问题可以从$f(n-1)$问题末尾添加一名男生得到，也可以从$f(n-2)$末尾添加两个女生得到。</p>
<p>  故有：$f(n)&#x3D;f(n-1)+f(n-2)$</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="11-多指针"><a href="#11-多指针" class="headerlink" title="11. 多指针"></a>11. 多指针</h2><h3 id="A-下一个排列"><a href="#A-下一个排列" class="headerlink" title="A. 下一个排列"></a>A. 下一个排列</h3><ul>
<li><p>细节</p>
<p>  两次从后向前扫描，第一次先找到第一个小的数，第二次找到最早比这个数大的数，之后交换位置，再将i之后的元素排序（等效于逆转）。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(string num)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i=num.<span class="built_in">size</span>() - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;=<span class="number">0</span>&amp;&amp;num[i]&gt;=num[i<span class="number">+1</span>])&#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> j=num.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j&gt;=<span class="number">0</span>&amp;&amp;num[i]&gt;=num[j])&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(num[i],num[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(num.<span class="built_in">begin</span>()+i<span class="number">+1</span>,num.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="B-交换相邻达成序列"><a href="#B-交换相邻达成序列" class="headerlink" title="B. 交换相邻达成序列"></a>B. 交换相邻达成序列</h3><ul>
<li><p>细节</p>
<p>  当遇到不同的时候就找之后最近的移动交换，这是最优的。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(num[i]!=pre[i])&#123;</span><br><span class="line">        <span class="type">int</span> ptr=i<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">while</span>(num[ptr]!=pre[i])&#123;</span><br><span class="line">            ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ptr!=i)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(num[ptr],num[ptr<span class="number">-1</span>]);</span><br><span class="line">            res++;</span><br><span class="line">            ptr--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Mark Goyens</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/10/07/Algorithm/">http://example.com/2024/10/07/Algorithm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Mark Goyens的闻雅轩</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/image/head.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/10/06/%E9%99%A2%E6%A0%A1%E6%8A%95%E9%80%92/" title="院校投递"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">院校投递</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/image/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Mark Goyens</div><div class="author-info__description">车车请再赢一次！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/MarkGoyens"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://www.douyin.com/user/MS4wLjABAAAAx6ziZFKQWA1b6HU3vybLhMkFkwQaD4457KK2-I2DDi8?from_tab_name=main" target="_blank" title="抖音"><i class="fab fa-tiktok" style="color: black;"></i></a><a class="social-icon" href="https://weibo.com/u/6336122801" target="_blank" title="微博"><i class="fab fa-weibo"></i></a><a class="social-icon" href="https://www.xiaohongshu.com/user/profile/64319703000000000f00486a" target="_blank" title="小红书"><i class="fas fa-book" style="color: red;"></i></a><a class="social-icon" href="https://blog.csdn.net/Curry0330?spm=1000.2115.3001.5343" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="mailto:120372390@qq.com" target="_blank" title=""><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center>欢迎访问我的个人网站！</center><center>本人计算机专业，车迷+铁佛寺+勇蜜</center><center>本站域名：</center><center><a target="_blank" rel="noopener" href="https://markgoyens.top">www.markgoyens.top</center></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">图论算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">1.1.</span> <span class="toc-text">1. 最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-Dijkstra-%E5%8D%95%E6%BA%90%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.1.</span> <span class="toc-text">A. Dijkstra(单源问题)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-BellmanFord-%E5%8D%95%E6%BA%90%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.2.</span> <span class="toc-text">B. BellmanFord(单源问题)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-Floyd-%E5%A4%9A%E6%BA%90%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.3.</span> <span class="toc-text">C. Floyd(多源问题)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-BFS-DFS%E8%A7%A3%E5%86%B3%E5%9B%BA%E5%AE%9A%E8%BE%B9%E6%9D%83%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.4.</span> <span class="toc-text">D. BFS&#x2F;DFS解决固定边权问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">2. 拓扑排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BA%8C%E9%83%A8%E5%9B%BE"><span class="toc-number">1.3.</span> <span class="toc-text">3. 二部图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.1.</span> <span class="toc-text">A. 最大匹配问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%AC%A7%E6%8B%89%E5%9B%BE"><span class="toc-number">1.4.</span> <span class="toc-text">4. 欧拉图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E5%AF%BB%E6%89%BE%E6%AC%A7%E6%8B%89%E9%80%9A%E8%B7%AF-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF"><span class="toc-number">1.4.1.</span> <span class="toc-text">A. 寻找欧拉通路&#x2F;欧拉回路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text">5. 树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.1.</span> <span class="toc-text">A. 树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#i-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">i. 先序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ii-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">ii. 中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iii-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">iii. 后序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iv-%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">iv. 邻接表表示的树的遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E7%9A%84%E9%87%8D%E5%BB%BA"><span class="toc-number">1.5.2.</span> <span class="toc-text">B. 树的重建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%9C%80%E5%B0%8F%EF%BC%88%E5%A4%A7%EF%BC%89%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.5.3.</span> <span class="toc-text">C. 最小（大）生成树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-%E5%85%B1%E5%90%8C%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.4.</span> <span class="toc-text">D. 共同祖先问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-%E5%B0%86%E6%A0%91%E5%88%86%E4%B8%BA%E5%92%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-number">1.5.5.</span> <span class="toc-text">E. 将树分为和相等的子树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#F-%E6%97%B6%E9%97%B4%E6%88%B3%E5%88%A4%E6%96%AD%E5%AE%9A%E4%B9%89%E6%A0%B9%E4%B8%8B%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.6.</span> <span class="toc-text">F. 时间戳判断定义根下的父子关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G-%E8%8A%82%E7%82%B9%E7%9A%84dfs%E5%BA%8F"><span class="toc-number">1.5.7.</span> <span class="toc-text">G. 节点的dfs序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%9C%88%EF%BC%88%E7%8E%AF%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">6. 圈（环）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-Floyd-%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.1.</span> <span class="toc-text">A. Floyd 判圈算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%97%A0%E5%90%91%E5%9B%BE%E6%9C%80%E5%B0%8F%E7%8E%AF%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.2.</span> <span class="toc-text">B. 无向图最小环问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%9C%89%E5%90%91%E5%9B%BE%E5%94%AF%E4%B8%80%E7%8E%AF%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.3.</span> <span class="toc-text">C. 有向图唯一环问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tarjan%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.</span> <span class="toc-text">tarjan算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E6%A1%A5-%E5%89%B2%E7%82%B9"><span class="toc-number">1.7.1.</span> <span class="toc-text">A. 桥&#x2F;割点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E6%94%AF"><span class="toc-number">1.7.2.</span> <span class="toc-text">B. 强连通分支</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E8%AE%BA"><span class="toc-number">2.</span> <span class="toc-text">数论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%94%9F%E6%88%90%E8%B4%A8%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">1. 生成质数问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">2.2.</span> <span class="toc-text">2. 快速幂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BF%AB%E9%80%9F%E4%B9%98"><span class="toc-number">2.3.</span> <span class="toc-text">3. 快速乘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">4. 最大公约数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E5%9F%BA%E6%9C%AC"><span class="toc-number">2.4.1.</span> <span class="toc-text">A. 基本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E8%BF%90%E7%94%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">B. 运用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">a. 裴蜀定理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">5. 分解质因数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-%E6%89%BE%E5%88%B0%E5%85%A8%E9%83%A8%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%8F%8A%E5%85%B6%E6%95%B0%E7%9B%AE"><span class="toc-number">2.5.1.</span> <span class="toc-text">a. 找到全部质因数及其数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b-%E8%AE%A1%E7%AE%971-n%E7%9A%84%E4%B9%98%E7%A7%AF%E7%9A%84%E6%9F%90%E4%B8%AA%E8%B4%A8%E6%95%B0%E7%9A%84%E5%A5%89%E7%8C%AE"><span class="toc-number">2.5.2.</span> <span class="toc-text">b. 计算1~n的乘积的某个质数的奉献</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%88%86%E8%A7%A3%E5%9B%A0%E5%AD%90"><span class="toc-number">2.6.</span> <span class="toc-text">6. 分解因子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%A4%84%E7%90%86"><span class="toc-number">2.7.</span> <span class="toc-text">7. 二进制处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E5%BF%AB%E9%80%9F%E8%8E%B7%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B01%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">2.7.1.</span> <span class="toc-text">A. 快速获取二进制数1的数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E5%BF%AB%E9%80%9F%E8%8E%B7%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E9%9B%86"><span class="toc-number">2.7.2.</span> <span class="toc-text">B. 快速获取二进制子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%8E%B7%E5%8F%96%E5%AD%90%E9%9B%86%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">2.7.3.</span> <span class="toc-text">C. 获取子集和数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-%E4%BB%85%E4%BF%9D%E7%95%99%E6%9C%80%E5%8F%B3%E8%BE%B91"><span class="toc-number">2.7.4.</span> <span class="toc-text">D. 仅保留最右边1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-%E6%A0%BC%E9%9B%B7%E7%A0%81%E7%BC%96%E7%A0%81"><span class="toc-number">2.7.5.</span> <span class="toc-text">E. 格雷码编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#F-%E7%AD%89%E6%95%88%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.7.6.</span> <span class="toc-text">F. 等效转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97"><span class="toc-number">2.8.</span> <span class="toc-text">8. 矩阵运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95"><span class="toc-number">2.8.1.</span> <span class="toc-text">A. 矩阵乘法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">2.8.2.</span> <span class="toc-text">B. 矩阵快速幂</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-n-n-%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">2.9.</span> <span class="toc-text">9. $n^n$的性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E7%BB%84%E5%90%88%E6%95%B0-%E9%98%B6%E4%B9%98"><span class="toc-number">2.10.</span> <span class="toc-text">10. 组合数&#x2F;阶乘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E6%96%B9%E6%B3%95"><span class="toc-number">2.10.1.</span> <span class="toc-text">维护方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.10.2.</span> <span class="toc-text">使用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E9%9A%94%E6%9D%BF%E6%B3%95"><span class="toc-number">2.10.2.1.</span> <span class="toc-text">A. 隔板法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%90%91%E9%87%8F%E6%B1%82%E8%A7%A3"><span class="toc-number">2.11.</span> <span class="toc-text">11. 向量求解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E4%B8%A4%E7%82%B9%E4%B8%8E%E5%8D%8A%E5%BE%84%E6%B1%82%E5%9C%86%E5%BF%83"><span class="toc-number">2.11.0.0.1.</span> <span class="toc-text">a. 两点与半径求圆心</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E8%A7%92%E5%BA%A6%E7%9B%B8%E5%85%B3"><span class="toc-number">2.11.0.0.2.</span> <span class="toc-text">b. 角度相关</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3"><span class="toc-number">2.12.</span> <span class="toc-text">12. 整数分解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-%E5%88%86%E8%A7%A3%E4%B8%BA%E4%B8%A4%E4%B8%AA%E7%9B%B8%E9%82%BB%E6%95%B4%E6%95%B0%E6%9E%84%E6%88%90%E7%9A%84%E6%9C%80%E5%B0%8F%E9%9B%86%E5%90%88"><span class="toc-number">2.12.1.</span> <span class="toc-text">a. 分解为两个相邻整数构成的最小集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E7%BB%9D%E5%AF%B9%E5%80%BC%E6%9C%80%E5%80%BC%E9%97%AE%E9%A2%98"><span class="toc-number">2.13.</span> <span class="toc-text">13. 绝对值最值问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-%E5%93%88%E5%AF%86%E9%A1%BF%E8%B7%9D%E7%A6%BB%E6%9C%80%E5%A4%A7"><span class="toc-number">2.13.1.</span> <span class="toc-text">a. 哈密顿距离最大</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E5%BE%8B"><span class="toc-number">2.14.</span> <span class="toc-text">14. 中国剩余定律</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E5%AE%B9%E6%96%A5%E5%AE%9A%E7%90%86"><span class="toc-number">2.15.</span> <span class="toc-text">15. 容斥定理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-%E5%80%8D%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-number">2.15.1.</span> <span class="toc-text">a. 倍数问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E6%80%A7%E8%B4%A8"><span class="toc-number">2.16.</span> <span class="toc-text">16. 逻辑操作性质</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95KMP"><span class="toc-number">3.1.</span> <span class="toc-text">1. 字符串匹配算法KMP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%89%A9%E5%B1%95KMP%EF%BC%88Z%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">2. 扩展KMP（Z函数）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">3.3.</span> <span class="toc-text">3. 回文串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E6%9F%90%E5%8C%BA%E9%97%B4%E6%98%AF%E5%90%A6%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">3.3.1.</span> <span class="toc-text">A. 快速判断某区间是否回文串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.3.2.</span> <span class="toc-text">B. 区间最大回文子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%8F%AA%E9%9C%80%E8%A6%81%E6%9C%80%E9%95%BF%E7%9A%84%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%88manacher%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">3.3.3.</span> <span class="toc-text">C. 只需要最长的回文串（manacher算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">3.3.4.</span> <span class="toc-text">D. 区间最大回文子串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9C%80%E5%A4%A7%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80LCP"><span class="toc-number">3.4.</span> <span class="toc-text">4. 最大公共前缀LCP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="toc-number">4.</span> <span class="toc-text">二分查找&#x2F;折半查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E5%86%85%E5%AE%B9%E7%9A%84%E4%B8%8A%E7%95%8C"><span class="toc-number">4.1.</span> <span class="toc-text">1. 查找一个内容的上界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E5%86%85%E5%AE%B9%E7%9A%84%E4%B8%8B%E7%95%8C"><span class="toc-number">4.2.</span> <span class="toc-text">2. 查找一个内容的下界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9F%A5%E6%89%BE%E5%8D%95%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E9%9B%B6%E7%82%B9"><span class="toc-number">4.3.</span> <span class="toc-text">3. 查找单调函数的零点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9F%A5%E6%89%BE%E5%87%B9%E5%87%B8%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E5%80%BC%E7%82%B9"><span class="toc-number">4.4.</span> <span class="toc-text">4. 查找凹凸函数的极值点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">5.1.</span> <span class="toc-text">1. 插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">5.1.1.</span> <span class="toc-text">A. 直接插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">5.1.2.</span> <span class="toc-text">B. 希尔排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">5.2.</span> <span class="toc-text">2. 冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">5.3.</span> <span class="toc-text">3. 快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">5.4.</span> <span class="toc-text">4. 选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">5.4.1.</span> <span class="toc-text">A. 简单选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">5.4.2.</span> <span class="toc-text">B. 堆排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">5.5.</span> <span class="toc-text">5. 归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">5.6.</span> <span class="toc-text">6. 基数排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.</span> <span class="toc-text">高级数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">6.1.</span> <span class="toc-text">1. 并查集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">6.2.</span> <span class="toc-text">2. 线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.1.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">维护前缀和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">6.2.1.2.</span> <span class="toc-text">维护区间最大值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">6.2.2.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">6.3.</span> <span class="toc-text">3. 树状数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E5%8D%95%E7%82%B9%E7%BB%B4%E6%8A%A4-%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">6.3.1.</span> <span class="toc-text">A. 单点维护 区间查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E5%8C%BA%E9%97%B4%E7%BB%B4%E6%8A%A4%EF%BC%88%E5%8D%95%E7%82%B9%E7%BB%B4%E6%8A%A4%EF%BC%89-%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">6.3.2.</span> <span class="toc-text">B. 区间维护（单点维护） 区间查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AD%97%E5%85%B8%E6%A0%91"><span class="toc-number">6.4.</span> <span class="toc-text">4. 字典树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%BB%9A%E5%8A%A8%E5%93%88%E5%B8%8C"><span class="toc-number">6.5.</span> <span class="toc-text">5. 滚动哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="toc-number">6.5.1.</span> <span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E8%B7%AF%E5%BE%84"><span class="toc-number">6.5.1.1.</span> <span class="toc-text">A. 最长公共子路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E8%B7%AF%E5%BE%84"><span class="toc-number">6.5.1.2.</span> <span class="toc-text">B. 最长公共子路径</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-bitset"><span class="toc-number">6.6.</span> <span class="toc-text">6. bitset</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-2"><span class="toc-number">6.6.1.</span> <span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%BC%98%E5%8C%96"><span class="toc-number">6.6.1.1.</span> <span class="toc-text">A. 01背包问题优化</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D"><span class="toc-number">7.</span> <span class="toc-text">梯度下降</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4"><span class="toc-number">7.1.</span> <span class="toc-text">具体步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">7.2.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E6%9C%8D%E5%8A%A1%E4%B8%AD%E5%BF%83%E7%9A%84%E6%9C%80%E4%BD%B3%E4%BD%8D%E7%BD%AE"><span class="toc-number">7.2.1.</span> <span class="toc-text">A. 服务中心的最佳位置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%80%9D%E7%BB%B4"><span class="toc-number">8.</span> <span class="toc-text">常见思维</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86"><span class="toc-number">8.1.</span> <span class="toc-text">1. 前缀和与差分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">8.2.</span> <span class="toc-text">2. 动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9"><span class="toc-number">8.2.1.</span> <span class="toc-text">重点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-3"><span class="toc-number">8.2.2.</span> <span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98-LIS-%E5%9F%BA%E4%BA%8E%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="toc-number">8.2.2.1.</span> <span class="toc-text">A. 最长递增子序列问题 LIS (基于二分搜索)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.2.2.</span> <span class="toc-text">B. 背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#I-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.2.2.1.</span> <span class="toc-text">I.完全背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#a-%E9%9D%A2%E8%AF%95%E9%A2%98-08-11-%E7%A1%AC%E5%B8%81"><span class="toc-number">8.2.2.2.1.1.</span> <span class="toc-text">a. 面试题 08.11. 硬币</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#b-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.2.2.1.2.</span> <span class="toc-text">b. 多项式乘法问题</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#II-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.2.2.2.</span> <span class="toc-text">II. 0-1背包问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9EDP"><span class="toc-number">8.2.2.3.</span> <span class="toc-text">C. 树上倍增DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">8.2.2.4.</span> <span class="toc-text">D. 最长公共子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-%E5%9B%9E%E6%96%87%E4%B8%B2%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.2.5.</span> <span class="toc-text">E. 回文串问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#F-%E5%88%86%E7%BB%84%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.2.6.</span> <span class="toc-text">F. 分组问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G-%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.2.7.</span> <span class="toc-text">G. 博弈问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#H-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.2.8.</span> <span class="toc-text">H. 最大子段和问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.2.9.</span> <span class="toc-text">I. 最大子矩阵和问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#J-%E6%B5%81%E6%B0%B4%E4%BD%9C%E4%B8%9A%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.2.10.</span> <span class="toc-text">J. 流水作业问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#K-%E6%95%B0%E4%BD%8DDP"><span class="toc-number">8.2.2.11.</span> <span class="toc-text">K. 数位DP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E7%BB%9F%E8%AE%A1%E8%8C%83%E5%9B%B4%E5%86%85X%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">8.2.2.11.1.</span> <span class="toc-text">A. 统计范围内X数字的数目</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E7%BB%9F%E8%AE%A1%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E6%AD%A5%E8%BF%9B%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE"><span class="toc-number">8.2.2.11.2.</span> <span class="toc-text">B. 统计范围内的步进数字数目</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E5%A5%BD%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">8.2.2.11.3.</span> <span class="toc-text">C. 找到所有好字符串</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#L-%E6%9C%80%E4%BC%98%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.2.2.12.</span> <span class="toc-text">L. 最优搜索二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#M-%E8%BD%AE%E5%BB%93%E7%BA%BF%E4%BC%98%E5%8C%96"><span class="toc-number">8.2.2.13.</span> <span class="toc-text">M. 轮廓线优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#N-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0DP"><span class="toc-number">8.2.2.14.</span> <span class="toc-text">N. 插入元素DP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="toc-number">8.3.</span> <span class="toc-text">3. 二分搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E7%BB%93%E5%90%88%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%89%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E7%AC%A6%E5%90%88%E7%82%B9"><span class="toc-number">8.3.1.</span> <span class="toc-text">A. 结合贪心算法找到最大符合点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E5%9F%BA%E4%BA%8E%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">8.3.2.</span> <span class="toc-text">B. 基于二分查找的动态规划</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">8.4.</span> <span class="toc-text">4. 拓扑排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%B4%AA%E5%BF%83"><span class="toc-number">8.5.</span> <span class="toc-text">5. 贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-4"><span class="toc-number">8.5.1.</span> <span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-Boyer-Moore-%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95"><span class="toc-number">8.5.1.1.</span> <span class="toc-text">A. Boyer-Moore 投票算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E5%8C%BA%E9%97%B4%E5%A4%84%E7%90%86-%E9%80%89%E5%8F%96%E6%9C%80%E5%B0%91%E5%8C%BA%E9%97%B4%E5%85%83%E7%B4%A0%E8%A6%86%E7%9B%96%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4"><span class="toc-number">8.5.1.2.</span> <span class="toc-text">B. 区间处理-选取最少区间元素覆盖指定区间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%8C%BA%E9%97%B4%E5%A4%84%E7%90%86-%E9%80%89%E5%8F%96%E6%9C%80%E5%B0%91%E7%9A%84%E7%82%B9%E4%BD%BF%E5%BE%97%E6%89%80%E6%9C%89%E7%9A%84%E5%8C%BA%E9%97%B4%E9%83%BD%E8%87%B3%E5%B0%91%E5%9C%A8%E8%8C%83%E5%9B%B4%E9%87%8C%E6%9C%89%E4%B8%80%E4%B8%AA%E7%82%B9"><span class="toc-number">8.5.1.3.</span> <span class="toc-text">C. 区间处理-选取最少的点使得所有的区间都至少在范围里有一个点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-Nim%E9%97%AE%E9%A2%98"><span class="toc-number">8.5.1.4.</span> <span class="toc-text">D. Nim问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-%E9%98%B6%E6%A2%AFNim%E9%97%AE%E9%A2%98"><span class="toc-number">8.5.1.5.</span> <span class="toc-text">E. 阶梯Nim问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86"><span class="toc-number">8.6.</span> <span class="toc-text">6. 数组处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-5"><span class="toc-number">8.6.1.</span> <span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E8%8E%B7%E5%8F%96k%E4%BD%8D%E6%9C%80%E5%A4%A7%E5%AD%97%E5%85%B8%E5%BA%8F%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">8.6.1.1.</span> <span class="toc-text">A. 获取k位最大字典序子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E8%8E%B7%E5%BE%97%E6%9C%80%E5%A4%A7%E5%AD%97%E5%85%B8%E5%BA%8F"><span class="toc-number">8.6.1.2.</span> <span class="toc-text">B. 合并两个数组获得最大字典序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%BB%A1%E8%B6%B3%E4%B8%80%E5%AE%9A%E6%9D%A1%E4%BB%B6%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">8.6.1.3.</span> <span class="toc-text">C. 满足一定条件的连续子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E6%9C%80%E5%B0%8F%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%95%B0"><span class="toc-number">8.6.1.4.</span> <span class="toc-text">D. 最小的第k个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E9%80%86%E6%95%B0%E5%AF%B9%E9%97%AE%E9%A2%98"><span class="toc-number">8.6.1.5.</span> <span class="toc-text">D. 逆数对问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACK%E5%AF%B9%E6%9C%80%E5%B0%8F%E5%92%8C"><span class="toc-number">8.6.1.6.</span> <span class="toc-text">E. 两个数组中第K对最小和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#F-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-number">8.6.1.7.</span> <span class="toc-text">F. 下一个排列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">8.7.</span> <span class="toc-text">7. 单调栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-6"><span class="toc-number">8.7.1.</span> <span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E5%B7%A6%EF%BC%88%E5%8F%B3%EF%BC%89%E4%BE%A7%E6%9C%80%E8%BF%91%E6%AF%94%E8%87%AA%E5%B7%B1%E5%B0%8F%EF%BC%88%E5%A4%A7%EF%BC%89%E7%9A%84%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE"><span class="toc-number">8.7.1.1.</span> <span class="toc-text">A. 左（右）侧最近比自己小（大）的元素位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E4%BA%8C%E7%BB%B4%E5%81%8F%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="toc-number">8.7.1.2.</span> <span class="toc-text">B. 二维偏序问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">8.8.</span> <span class="toc-text">8. 单调队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-7"><span class="toc-number">8.8.1.</span> <span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E5%B8%A6%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C"><span class="toc-number">8.8.1.1.</span> <span class="toc-text">A. 带限制的子序列和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E7%AA%97%E5%8F%A3%E4%B8%AD%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">8.8.1.2.</span> <span class="toc-text">B. 窗口中最大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%89%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">8.8.1.3.</span> <span class="toc-text">C. 找到最大非递减数组的长度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%88%86%E6%B2%BB"><span class="toc-number">8.9.</span> <span class="toc-text">9. 分治</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E9%80%92%E5%BD%92"><span class="toc-number">8.10.</span> <span class="toc-text">10. 递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%A4%9A%E6%8C%87%E9%92%88"><span class="toc-number">8.11.</span> <span class="toc-text">11. 多指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-number">8.11.1.</span> <span class="toc-text">A. 下一个排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E4%BA%A4%E6%8D%A2%E7%9B%B8%E9%82%BB%E8%BE%BE%E6%88%90%E5%BA%8F%E5%88%97"><span class="toc-number">8.11.2.</span> <span class="toc-text">B. 交换相邻达成序列</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/07/Algorithm/" title="Algorithm">Algorithm</a><time datetime="2024-10-07T08:19:22.529Z" title="发表于 2024-10-07 16:19:22">2024-10-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/06/%E9%99%A2%E6%A0%A1%E6%8A%95%E9%80%92/" title="院校投递">院校投递</a><time datetime="2024-10-06T05:33:38.546Z" title="发表于 2024-10-06 13:33:38">2024-10-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/28/hello-world/" title="Hello World">Hello World</a><time datetime="2024-09-28T02:31:47.471Z" title="发表于 2024-09-28 10:31:47">2024-09-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Mark Goyens</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><p>学无止境，气有浩然；愿行跬步，以致千里</p><p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ ">&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>